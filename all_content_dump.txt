# lib/auth_screen.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:yoto/stores/auth_store.dart';
import 'package:yoto/widgets/auth_button.dart';
import 'package:yoto/widgets/custome_text_field.dart';

class AuthScreen extends StatefulWidget {
  const AuthScreen({super.key});

  @override
  State<AuthScreen> createState() => _AuthScreenState();
}

class _AuthScreenState extends State<AuthScreen> {
  final _formKey = GlobalKey<FormState>();
  final emailController = TextEditingController();
  final passController = TextEditingController();

  bool isLogin = true;

  @override
  void dispose() {
    emailController.dispose();
    passController.dispose();
    super.dispose();
  }

  void _toggleAuthMode() {
    setState(() {
      isLogin = !isLogin;
    });
  }

  Future<void> _submitForm() async {
    if (_formKey.currentState?.validate() ?? false) {
      try {
        final email = emailController.text.trim();
        final password = passController.text.trim();
        final authStore = Provider.of<AuthStore>(context, listen: false);

        if (isLogin) {
          await authStore.signIn(email, password);
        } else {
          await authStore.signUp(email, password);
        }

        Navigator.of(context).pushReplacementNamed('/');
      } catch (e) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text(e.toString())),
        );
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final authStore = Provider.of<AuthStore>(context, listen: false);
    final isDarkMode = Theme.of(context).brightness == Brightness.dark;
    return Scaffold(
      backgroundColor: isDarkMode ? Colors.black : Colors.white,
      body: SafeArea(
        child: Center(
          child: SingleChildScrollView(
            child: Padding(
              padding: const EdgeInsets.all(24.0),
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(
                    Icons.chat_bubble_outline,
                    size: 80,
                    color: isDarkMode
                        ? Theme.of(context).highlightColor
                        : Theme.of(context).primaryColor,
                  ),
                  const SizedBox(height: 24),
                  Text(
                    isLogin ? 'Welcome Back' : 'Create Account',
                    style: TextStyle(
                      fontSize: 28,
                      fontWeight: FontWeight.bold,
                      color: isDarkMode ? Colors.white : Colors.black,
                    ),
                  ),
                  const SizedBox(height: 24),
                  Form(
                    key: _formKey,
                    child: Column(
                      children: [
                        CustomTextField(
                          controller: emailController,
                          hintText: 'Email',
                          icon: Icons.email_outlined,
                          validator: authStore.validateEmail,
                        ),
                        const SizedBox(height: 16),
                        CustomTextField(
                          controller: passController,
                          hintText: 'Password',
                          icon: Icons.lock_outline,
                          obscureText: true,
                          validator: authStore.validatePassword,
                        ),
                      ],
                    ),
                  ),
                  const SizedBox(height: 24),
                  AuthButton(
                    text: isLogin ? 'Log In' : 'Sign Up',
                    onPressed: _submitForm,
                  ),
                  const SizedBox(height: 16),
                  TextButton(
                    onPressed: _toggleAuthMode,
                    child: Text(
                      isLogin
                          ? 'Don\'t have an account? Sign Up'
                          : 'Already have an account? Log In',
                      style: TextStyle(
                          color: Theme.of(context).colorScheme.secondary),
                    ),
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}


# lib/firebase_options.dart
// File generated by FlutterFire CLI.
// ignore_for_file: lines_longer_than_80_chars, avoid_classes_with_only_static_members
import 'package:firebase_core/firebase_core.dart' show FirebaseOptions;
import 'package:flutter/foundation.dart'
    show defaultTargetPlatform, kIsWeb, TargetPlatform;

/// Default [FirebaseOptions] for use with your Firebase apps.
///
/// Example:
/// ```dart
/// import 'firebase_options.dart';
/// // ...
/// await Firebase.initializeApp(
///   options: DefaultFirebaseOptions.currentPlatform,
/// );
/// ```
class DefaultFirebaseOptions {
  static FirebaseOptions get currentPlatform {
    if (kIsWeb) {
      return web;
    }
    switch (defaultTargetPlatform) {
      case TargetPlatform.android:
        return android;
      case TargetPlatform.iOS:
        return ios;
      case TargetPlatform.macOS:
        return macos;
      case TargetPlatform.windows:
        return windows;
      case TargetPlatform.linux:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for linux - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      default:
        throw UnsupportedError(
          'DefaultFirebaseOptions are not supported for this platform.',
        );
    }
  }

  static const FirebaseOptions web = FirebaseOptions(
    apiKey: 'AIzaSyCUoIB-Ng-im33Ii9B9O49MjGkSFJsHoJw',
    appId: '1:327775764664:web:94b48eae272a9da559344d',
    messagingSenderId: '327775764664',
    projectId: 'flutter-c91c8',
    authDomain: 'flutter-c91c8.firebaseapp.com',
    databaseURL: 'https://flutter-c91c8-default-rtdb.asia-southeast1.firebasedatabase.app',
    storageBucket: 'flutter-c91c8.appspot.com',
    measurementId: 'G-V327W8PRSZ',
  );

  static const FirebaseOptions android = FirebaseOptions(
    apiKey: 'AIzaSyDf5YW44ebirOb4CQU2TOkGA_cFcq2LEE0',
    appId: '1:327775764664:android:467af3283cb965d059344d',
    messagingSenderId: '327775764664',
    projectId: 'flutter-c91c8',
    databaseURL: 'https://flutter-c91c8-default-rtdb.asia-southeast1.firebasedatabase.app',
    storageBucket: 'flutter-c91c8.appspot.com',
  );

  static const FirebaseOptions ios = FirebaseOptions(
    apiKey: 'AIzaSyCooTlr8MPr8ssgBct0YRuyW_v2ogVSEKE',
    appId: '1:327775764664:ios:dbea90814185020459344d',
    messagingSenderId: '327775764664',
    projectId: 'flutter-c91c8',
    databaseURL: 'https://flutter-c91c8-default-rtdb.asia-southeast1.firebasedatabase.app',
    storageBucket: 'flutter-c91c8.appspot.com',
    iosClientId: '327775764664-n9faega4pj87gt6ovr4qvhq8uusrkumh.apps.googleusercontent.com',
    iosBundleId: 'com.example.chatApp',
  );

  static const FirebaseOptions macos = FirebaseOptions(
    apiKey: 'AIzaSyCooTlr8MPr8ssgBct0YRuyW_v2ogVSEKE',
    appId: '1:327775764664:ios:dbea90814185020459344d',
    messagingSenderId: '327775764664',
    projectId: 'flutter-c91c8',
    databaseURL: 'https://flutter-c91c8-default-rtdb.asia-southeast1.firebasedatabase.app',
    storageBucket: 'flutter-c91c8.appspot.com',
    iosClientId: '327775764664-n9faega4pj87gt6ovr4qvhq8uusrkumh.apps.googleusercontent.com',
    iosBundleId: 'com.example.chatApp',
  );

  static const FirebaseOptions windows = FirebaseOptions(
    apiKey: 'AIzaSyCUoIB-Ng-im33Ii9B9O49MjGkSFJsHoJw',
    appId: '1:327775764664:web:174be248f1dd3e6459344d',
    messagingSenderId: '327775764664',
    projectId: 'flutter-c91c8',
    authDomain: 'flutter-c91c8.firebaseapp.com',
    databaseURL: 'https://flutter-c91c8-default-rtdb.asia-southeast1.firebasedatabase.app',
    storageBucket: 'flutter-c91c8.appspot.com',
    measurementId: 'G-K744E64FQ9',
  );

}

# lib/main.dart
import 'package:flutter/material.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:flutter/widgets.dart';
import 'package:provider/provider.dart';
import 'package:flutter_mobx/flutter_mobx.dart';
import 'package:yoto/auth_screen.dart';
import 'package:yoto/firebase_options.dart';
// import 'package:yoto/screens/anonymous_chat_screen';
import 'package:yoto/screens/chat_screen.dart';
// import 'package:yoto/screens/chat_screen.dart';
import 'package:yoto/services/firestore_service.dart';
import 'package:yoto/services/graphql_service.dart';
import 'package:yoto/services/serverless_service.dart';
import 'package:yoto/stores/auth_store.dart';
import 'package:yoto/stores/profile_store.dart';
import 'package:yoto/stores/match_store.dart';
import 'package:yoto/stores/chat_store.dart';
import 'package:yoto/stores/friend_store.dart';
import 'package:yoto/services/socket_service.dart';
import 'package:yoto/screens/home_screen.dart';
import 'package:yoto/screens/profile_edit_screen.dart';
import 'package:yoto/screens/search_screen.dart';
import 'package:yoto/screens/profile_screen.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await Firebase.initializeApp(options: DefaultFirebaseOptions.currentPlatform);

  final socketService = SocketService();
  final serverlessService = ServerlessService();
  final firestoreService = FirestoreService();
  final graphqlservice = Graphqlservice();

  final authStore = AuthStore();
  await authStore.init();

  final profileStore = ProfileStore();
  final matchStore =
      MatchStore(socketService, serverlessService, firestoreService);
  final chatStore = ChatStore(socketService);
  final friendStore = FriendStore(firestoreService, graphqlservice);

  runApp(
    MultiProvider(
      providers: [
        Provider<AuthStore>(create: (_) => authStore),
        Provider<ProfileStore>(create: (_) => profileStore),
        Provider<MatchStore>(create: (_) => matchStore),
        Provider<ChatStore>(
          create: (_) => chatStore,
          dispose: (_, store) => store.dispose(),
        ),
        Provider<FriendStore>(create: (_) => friendStore),
      ],
      child: MyApp(),
    ),
  );
}

class MyApp extends StatelessWidget {
  MyApp({Key? key}) : super(key: key);
  
  final Map<String, Widget Function(BuildContext)> routes = {
      '/home': (context) => const HomeScreen(),
      '/auth': (context) => const AuthScreen(),
      '/profile': (context) => const ProfileScreen(),
      '/profile_edit': (context) => const ProfileEditScreen(),
      '/search': (context) => const SearchScreen(),
      '/anonymous_chat': (context) {
        final args =
            ModalRoute.of(context)!.settings.arguments as Map<String, dynamic>;
        return ChatScreen(
          chatId: args['chatId'],
          friendId: args['friendId'],
          isFriend: false,
        );
      },
      '/chat': (context) {
        final args =
            ModalRoute.of(context)!.settings.arguments as Map<String, dynamic>;
        return ChatScreen(
          chatId: args['chatId'],
          friendId: args['friendId'],
          isFriend: true,
        );
      },
    };
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Yoto Chat App',
      theme: ThemeData(
        primarySwatch: Colors.teal,
        brightness: Brightness.light,
      ),
      darkTheme: ThemeData(
        primarySwatch: Colors.teal,
        brightness: Brightness.dark,
      ),
      themeMode: ThemeMode.system,
      home: const AuthWrapper(),
      routes: routes,
    );
  }
}

class AuthWrapper extends StatelessWidget {
  const AuthWrapper({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final authStore = Provider.of<AuthStore>(context);
    final profileStore = Provider.of<ProfileStore>(context);
    final chatStore = Provider.of<ChatStore>(context, listen: false);
    final friendStore = Provider.of<FriendStore>(context, listen: false);

    return Observer(
      builder: (_) {
        if (authStore.isLoggedIn) {
          profileStore.fetchProfileData();
          if (!profileStore.isProfileComplete) {
            return ProfileEditScreen(
                isNewUser: profileStore.profileData == null);
          } else {
            // Register the user with the socket server when logged in
            chatStore.registerUser(authStore.currentUser!.uid);
            // Load friends list
            friendStore.loadFriends(authStore.currentUser!.uid);
            return const HomeScreen();
          }
        } else {
          return const AuthScreen();
        }
      },
    );
  }
}


# lib/screens/anonymous_chat_screen
import 'dart:async';
import 'package:flutter/material.dart';
import 'package:flutter_chat_ui/flutter_chat_ui.dart';
import 'package:flutter_chat_types/flutter_chat_types.dart' as types;
import 'package:provider/provider.dart';
import 'package:flutter_mobx/flutter_mobx.dart';
import 'package:yoto/stores/auth_store.dart';
import 'package:yoto/stores/chat_store.dart';
import 'package:yoto/stores/match_store.dart';

class AnonymousChatScreen extends StatefulWidget {
  final String chatId;
  final String otherUserId;

  const AnonymousChatScreen({
    Key? key,
    required this.chatId,
    required this.otherUserId,
  }) : super(key: key);

  @override
  AnonymousChatScreenState createState() => AnonymousChatScreenState();
}

class AnonymousChatScreenState extends State<AnonymousChatScreen> {
  late Timer _timer;
  int _secondsRemaining = 15 * 60; // 15 minutes

  @override
  void initState() {
    super.initState();
    _startTimer();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      final chatStore = Provider.of<ChatStore>(context, listen: false);
      chatStore.loadMessages(widget.chatId);
    });
  }

  void _startTimer() {
    _timer = Timer.periodic(const Duration(seconds: 1), (timer) {
      setState(() {
        if (_secondsRemaining > 0) {
          _secondsRemaining--;
        } else {
          _endChat();
        }
      });
    });
  }

  void _endChat() {
    _timer.cancel();
    final matchStore = Provider.of<MatchStore>(context, listen: false);
    matchStore.endChat(widget.chatId, widget.otherUserId);
    Navigator.of(context).pushReplacementNamed('/home');
  }

  Future<void> _sendFriendRequest() async {
    final matchStore = Provider.of<MatchStore>(context, listen: false);
    final authStore = Provider.of<AuthStore>(context, listen: false);
    try {
      matchStore.sendFriendRequest(authStore.currentUser!.uid, widget.chatId);
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Friend request sent!')),
      );
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Failed to send friend request: $e')),
      );
    }
  }

  String _formatTime(int seconds) {
    int minutes = seconds ~/ 60;
    int remainingSeconds = seconds % 60;
    return '${minutes.toString().padLeft(2, '0')}:${remainingSeconds.toString().padLeft(2, '0')}';
  }

  @override
  Widget build(BuildContext context) {
    final authStore = Provider.of<AuthStore>(context);
    final chatStore = Provider.of<ChatStore>(context);
    final matchStore = Provider.of<MatchStore>(context);
    final isDarkMode = Theme.of(context).brightness == Brightness.dark;

    return Observer(
      builder: (_) {
        if (matchStore.isChatEnded || matchStore.areFriendsNow) {
          WidgetsBinding.instance.addPostFrameCallback((_) {
            Navigator.of(context).pushReplacementNamed('/home');
          });
          return const Scaffold(
              body: Center(child: CircularProgressIndicator()));
        }

        return Theme(
          data: isDarkMode ? ThemeData.dark() : ThemeData.light(),
          child: Scaffold(
            appBar: AppBar(
              backgroundColor: isDarkMode ? Colors.grey[900] : Colors.teal,
              title: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  const Text('Anonymous Chat'),
                  Text(
                    _formatTime(_secondsRemaining),
                    style: const TextStyle(fontSize: 12),
                  ),
                ],
              ),
              actions: [
                PopupMenuButton<String>(
                  onSelected: (value) {
                    if (value == 'sendFriendRequest') {
                      _sendFriendRequest();
                    } else if (value == 'endChat') {
                      _endChat();
                    }
                  },
                  itemBuilder: (BuildContext context) => [
                    const PopupMenuItem<String>(
                      value: 'sendFriendRequest',
                      child: Text('Send Friend Request'),
                    ),
                    const PopupMenuItem<String>(
                      value: 'endChat',
                      child: Text('End Chat'),
                    ),
                  ],
                ),
              ],
            ),
            body: Chat(
              messages: chatStore.getMessagesForChat(widget.chatId),
              onSendPressed: (types.PartialText message) {
                chatStore.sendMessage(
                  widget.chatId,
                  message.text,
                  authStore.currentUser!.uid,
                );
              },
              user: types.User(id: authStore.currentUser!.uid),
              theme:
                  isDarkMode ? const DarkChatTheme() : const DefaultChatTheme(),
            ),
          ),
        );
      },
    );
  }

  @override
  void dispose() {
    _timer.cancel();
    super.dispose();
  }
}


# lib/screens/_chat_screen.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:yoto/stores/chat_store.dart';
import 'package:yoto/stores/auth_store.dart';
import 'package:intl/intl.dart';

class ChatScreen extends StatefulWidget {
  final String chatId;
  final String friendId;
  final bool isFriend;

  const ChatScreen(
      {Key? key,
      required this.chatId,
      required this.friendId,
      this.isFriend = false})
      : super(key: key);

  @override
  ChatScreenState createState() => ChatScreenState();
}

class ChatScreenState extends State<ChatScreen> {
  final TextEditingController _textController = TextEditingController();
  final ScrollController _scrollController = ScrollController();

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      final chatStore = Provider.of<ChatStore>(context, listen: false);
      chatStore.loadMessages(widget.chatId);
    });
  }

  void _handleSendPressed() {
    if (_textController.text.trim().isNotEmpty) {
      final chatStore = Provider.of<ChatStore>(context, listen: false);
      final authStore = Provider.of<AuthStore>(context, listen: false);
      chatStore.sendMessage(widget.chatId, _textController.text.trim(),
          authStore.currentUser!.uid);
      _textController.clear();
      _scrollController.animateTo(
        0.0,
        curve: Curves.easeOut,
        duration: const Duration(milliseconds: 300),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        backgroundColor: Colors.white,
        elevation: 0,
        leading: IconButton(
          icon: const Icon(Icons.arrow_back, color: Colors.black),
          onPressed: () => Navigator.of(context).pop(),
        ),
        title: const Row(
          children: [
            SizedBox(width: 12),
            Text(
              'widget.friendId',
              style:
                  TextStyle(color: Colors.black, fontWeight: FontWeight.bold),
            ),
          ],
        ),
        actions: const [
          CircleAvatar(
            backgroundImage: NetworkImage(
                'https://example.com/user_avatar.jpg'), // Replace with user's avatar URL
            radius: 18,
          ),
          SizedBox(width: 16),
        ],
      ),
      body: Column(
        children: [
          Expanded(
            child: Consumer<ChatStore>(
              builder: (context, chatStore, child) {
                final messages = chatStore.getMessagesForChat(widget.chatId);
                return ListView.builder(
                  reverse: true,
                  controller: _scrollController,
                  itemCount: messages.length,
                  itemBuilder: (context, index) {
                    final message = messages[index];
                    return _buildMessageBubble(message);
                  },
                );
              },
            ),
          ),
          _buildInputArea(),
        ],
      ),
    );
  }

  Widget _buildMessageBubble(dynamic message) {
    return Builder(
      builder: (BuildContext context) {
        final authStore = Provider.of<AuthStore>(context, listen: false);
        final isMe = message.author.id == authStore.currentUser!.uid;
        final isDarkMode = Theme.of(context).brightness == Brightness.dark;

        // Define colors based on the theme
        final myMessageColor = isDarkMode ? Colors.teal[700] : Colors.blue[100];
        final otherMessageColor =
            isDarkMode ? Colors.grey[800] : Colors.grey[200];
        final textColor = isDarkMode ? Colors.white : Colors.black;
        final timestampColor = isDarkMode ? Colors.grey[400] : Colors.grey[600];

        return Align(
          alignment: isMe ? Alignment.centerRight : Alignment.centerLeft,
          child: Container(
            margin: const EdgeInsets.symmetric(vertical: 4, horizontal: 8),
            padding: const EdgeInsets.symmetric(vertical: 8, horizontal: 12),
            decoration: BoxDecoration(
              color: isMe ? myMessageColor : otherMessageColor,
              borderRadius: BorderRadius.circular(20),
              boxShadow: [
                BoxShadow(
                  color: Colors.black.withOpacity(0.1),
                  blurRadius: 3,
                  offset: const Offset(0, 2),
                ),
              ],
            ),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  message.text,
                  style: TextStyle(
                    fontSize: 16,
                    color: textColor,
                  ),
                ),
                const SizedBox(height: 4),
                Text(
                  DateFormat('HH:mm').format(
                    DateTime.fromMillisecondsSinceEpoch(message.createdAt),
                  ),
                  style: TextStyle(
                    fontSize: 12,
                    color: timestampColor,
                  ),
                ),
              ],
            ),
          ),
        );
      },
    );
  }

  Widget _buildInputArea() {
    return Builder(
      builder: (BuildContext context) {
        final isDarkMode = Theme.of(context).brightness == Brightness.dark;
        final backgroundColor = isDarkMode ? Colors.grey[900] : Colors.white;
        final inputBackgroundColor =
            isDarkMode ? Colors.grey[800] : Colors.grey[200];
        final iconColor = isDarkMode ? Colors.grey[400] : Colors.grey[600];
        final textColor = isDarkMode ? Colors.white : Colors.black;

        return Container(
          padding: const EdgeInsets.symmetric(horizontal: 8.0, vertical: 8.0),
          color: backgroundColor,
          child: Row(
            children: [
              IconButton(
                icon: Icon(Icons.add, color: iconColor),
                onPressed: () {
                  // Implement add attachment functionality
                },
              ),
              Expanded(
                child: ConstrainedBox(
                  constraints: const BoxConstraints(
                    minHeight: 40.0,
                    maxHeight: 120.0,
                  ),
                  child: TextField(
                    controller: _textController,
                    focusNode: FocusNode(),
                    maxLines: null,
                    textCapitalization: TextCapitalization.sentences,
                    style: TextStyle(color: textColor),
                    decoration: InputDecoration(
                      hintText: 'Aa',
                      hintStyle: TextStyle(color: iconColor),
                      border: OutlineInputBorder(
                        borderRadius: BorderRadius.circular(24.0),
                        borderSide: BorderSide.none,
                      ),
                      filled: true,
                      fillColor: inputBackgroundColor,
                      contentPadding: const EdgeInsets.symmetric(
                          horizontal: 16.0, vertical: 8.0),
                    ),
                  ),
                ),
              ),
              IconButton(
                icon: Icon(Icons.mic, color: iconColor),
                onPressed: () {
                  // Implement voice message functionality
                },
              ),
              IconButton(
                icon: Icon(Icons.send, color: iconColor),
                onPressed: _handleSendPressed,
              ),
            ],
          ),
        );
      },
    );
  }

  @override
  void dispose() {
    _textController.dispose();
    _scrollController.dispose();
    super.dispose();
  }
}


# lib/screens/~chat_screen.dart
import 'dart:async';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:intl/intl.dart';
import 'package:yoto/stores/chat_store.dart';
import 'package:yoto/stores/auth_store.dart';
import 'package:yoto/stores/friend_store.dart';
import 'package:yoto/stores/match_store.dart';

class ChatScreen extends StatefulWidget {
  final String chatId;
  final String friendId;
  final bool isFriend;

  const ChatScreen({
    Key? key,
    required this.chatId,
    required this.friendId,
    this.isFriend = false,
  }) : super(key: key);

  @override
  ChatScreenState createState() => ChatScreenState();
}

class ChatScreenState extends State<ChatScreen> {
  final TextEditingController _textController = TextEditingController();
  final ScrollController _scrollController = ScrollController();
  String friendName = 'Strange';
  String avatar = '';
  late Timer _timer;
  int _secondsRemaining = 15 * 60; // 15 minutes for anonymous chat

  @override
  void initState() {
    super.initState();
    if (!widget.isFriend) {
      _startTimer();
    }
    WidgetsBinding.instance.addPostFrameCallback((_) {
      final chatStore = Provider.of<ChatStore>(context, listen: false);
      chatStore.loadMessages(widget.chatId);
    });
    if (widget.isFriend) {
      _loadFriendProfile();
    }
  }

  void _startTimer() {
    _timer = Timer.periodic(const Duration(seconds: 1), (timer) {
      setState(() {
        if (_secondsRemaining > 0) {
          _secondsRemaining--;
        } else {
          _endChat();
        }
      });
    });
  }

  void _endChat() {
    if (!widget.isFriend) {
      _timer.cancel();
      final matchStore = Provider.of<MatchStore>(context, listen: false);
      matchStore.endChat(widget.chatId, widget.friendId);
      Navigator.of(context).pushReplacementNamed('/home');
    }
  }

  Future<void> _loadFriendProfile() async {
    final friendStore = Provider.of<FriendStore>(context, listen: false);
    Map<String, dynamic>? friendProfile =
        await friendStore.getFriendProfile(widget.friendId);
    if (friendProfile != null) {
      setState(() {
        friendName = friendProfile['displayName'];
        avatar = friendProfile['profileImageUrl'];
      });
    }
  }

  Future<void> _sendFriendRequest() async {
    final matchStore = Provider.of<MatchStore>(context, listen: false);
    final authStore = Provider.of<AuthStore>(context, listen: false);
    try {
      matchStore.sendFriendRequest(authStore.currentUser!.uid, widget.chatId);
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Friend request sent!')),
      );
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Failed to send friend request: $e')),
      );
    }
  }

  String _formatTime(int seconds) {
    int minutes = seconds ~/ 60;
    int remainingSeconds = seconds % 60;
    return '${minutes.toString().padLeft(2, '0')}:${remainingSeconds.toString().padLeft(2, '0')}';
  }

  void _handleSendPressed() {
    if (_textController.text.trim().isNotEmpty) {
      final chatStore = Provider.of<ChatStore>(context, listen: false);
      final authStore = Provider.of<AuthStore>(context, listen: false);
      chatStore.sendMessage(widget.chatId, _textController.text.trim(),
          authStore.currentUser!.uid);
      _textController.clear();
      _scrollController.animateTo(
        0.0,
        curve: Curves.easeOut,
        duration: const Duration(milliseconds: 300),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    final isDarkMode = Theme.of(context).brightness == Brightness.dark;
    final matchStore = Provider.of<MatchStore>(context, listen: false);
    if (matchStore.isChatEnded) {
      Navigator.of(context).pushReplacementNamed('/home');
    }
    return Scaffold(
      appBar: AppBar(
        backgroundColor: isDarkMode ? Colors.grey[900] : Colors.white,
        elevation: 0,
        leading: IconButton(
          icon: Icon(Icons.arrow_back,
              color: isDarkMode ? Colors.white : Colors.black),
          onPressed: () => Navigator.of(context).pop(),
        ),
        title: Row(
          children: [
            const SizedBox(width: 12),
            Text(
              friendName,
              style: TextStyle(
                color: isDarkMode ? Colors.white : Colors.black,
                fontWeight: FontWeight.bold,
              ),
            ),
          ],
        ),
        actions: [
          if (!widget.isFriend) ...[
            Center(
              child: Text(
                _formatTime(_secondsRemaining),
                style: TextStyle(
                  fontSize: 12,
                  color: isDarkMode ? Colors.white : Colors.black,
                ),
              ),
            ),
            PopupMenuButton<String>(
              onSelected: (value) {
                if (value == 'sendFriendRequest') {
                  _sendFriendRequest();
                } else if (value == 'endChat') {
                  _endChat();
                }
              },
              itemBuilder: (BuildContext context) => [
                const PopupMenuItem<String>(
                  value: 'sendFriendRequest',
                  child: Text('Send Friend Request'),
                ),
                const PopupMenuItem<String>(
                  value: 'endChat',
                  child: Text('End Chat'),
                ),
              ],
            ),
          ] else ...[
            CircleAvatar(
              backgroundImage: NetworkImage(
                avatar, // Replace with user's avatar URL
              ),
              radius: 18,
            ),
          ],
          const SizedBox(width: 16),
        ],
      ),
      body: Column(
        children: [
          Expanded(
            child: Consumer<ChatStore>(
              builder: (context, chatStore, child) {
                final messages = chatStore.getMessagesForChat(widget.chatId);
                return ListView.builder(
                  reverse: true,
                  controller: _scrollController,
                  itemCount: messages.length,
                  itemBuilder: (context, index) {
                    final message = messages[index];
                    return _buildMessageBubble(message);
                  },
                );
              },
            ),
          ),
          _buildInputArea(),
        ],
      ),
    );
  }

  Widget _buildMessageBubble(dynamic message) {
    return Builder(
      builder: (BuildContext context) {
        final authStore = Provider.of<AuthStore>(context, listen: false);
        final isMe = message.author.id == authStore.currentUser!.uid;
        final isDarkMode = Theme.of(context).brightness == Brightness.dark;

        final myMessageColor = isDarkMode ? Colors.teal[700] : Colors.blue[100];
        final otherMessageColor =
            isDarkMode ? Colors.grey[800] : Colors.grey[200];
        final textColor = isDarkMode ? Colors.white : Colors.black;
        final timestampColor = isDarkMode ? Colors.grey[400] : Colors.grey[600];

        return Align(
          alignment: isMe ? Alignment.centerRight : Alignment.centerLeft,
          child: Container(
            margin: const EdgeInsets.symmetric(vertical: 4, horizontal: 8),
            padding: const EdgeInsets.symmetric(vertical: 8, horizontal: 12),
            decoration: BoxDecoration(
              color: isMe ? myMessageColor : otherMessageColor,
              borderRadius: BorderRadius.circular(20),
              boxShadow: [
                BoxShadow(
                  color: Colors.black.withOpacity(0.1),
                  blurRadius: 3,
                  offset: const Offset(0, 2),
                ),
              ],
            ),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  message.text,
                  style: TextStyle(
                    fontSize: 16,
                    color: textColor,
                  ),
                ),
                const SizedBox(height: 4),
                Text(
                  DateFormat('HH:mm').format(
                    DateTime.fromMillisecondsSinceEpoch(message.createdAt),
                  ),
                  style: TextStyle(
                    fontSize: 12,
                    color: timestampColor,
                  ),
                ),
              ],
            ),
          ),
        );
      },
    );
  }

  Widget _buildInputArea() {
    return Builder(
      builder: (BuildContext context) {
        final isDarkMode = Theme.of(context).brightness == Brightness.dark;
        final backgroundColor = isDarkMode ? Colors.grey[900] : Colors.white;
        final inputBackgroundColor =
            isDarkMode ? Colors.grey[800] : Colors.grey[200];
        final iconColor = isDarkMode ? Colors.grey[400] : Colors.grey[600];
        final textColor = isDarkMode ? Colors.white : Colors.black;

        return Container(
          padding: const EdgeInsets.symmetric(horizontal: 8.0, vertical: 8.0),
          color: backgroundColor,
          child: Row(
            children: [
              if (widget.isFriend)
                IconButton(
                  icon: Icon(Icons.add, color: iconColor),
                  onPressed: () {
                    // Implement add attachment functionality
                  },
                ),
              Expanded(
                child: ConstrainedBox(
                  constraints: const BoxConstraints(
                    minHeight: 40.0,
                    maxHeight: 120.0,
                  ),
                  child: TextField(
                    controller: _textController,
                    focusNode: FocusNode(),
                    maxLines: null,
                    textCapitalization: TextCapitalization.sentences,
                    style: TextStyle(color: textColor),
                    decoration: InputDecoration(
                      hintText: 'Aa',
                      hintStyle: TextStyle(color: iconColor),
                      border: OutlineInputBorder(
                        borderRadius: BorderRadius.circular(24.0),
                        borderSide: BorderSide.none,
                      ),
                      filled: true,
                      fillColor: inputBackgroundColor,
                      contentPadding: const EdgeInsets.symmetric(
                          horizontal: 16.0, vertical: 8.0),
                    ),
                  ),
                ),
              ),
              if (widget.isFriend)
                IconButton(
                  icon: Icon(Icons.mic, color: iconColor),
                  onPressed: () {
                    // Implement voice message functionality
                  },
                ),
              IconButton(
                icon: Icon(Icons.send, color: iconColor),
                onPressed: _handleSendPressed,
              ),
            ],
          ),
        );
      },
    );
  }

  @override
  void dispose() {
    _textController.dispose();
    _scrollController.dispose();
    if (!widget.isFriend) {
      _timer.cancel();
    }
    super.dispose();
  }
}


# lib/screens/chat_screen.dart
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter_mobx/flutter_mobx.dart';
import 'package:provider/provider.dart';
import 'package:yoto/widgets/chat_appbar.dart';
import 'package:yoto/widgets/chat_input_area.dart';
import 'package:yoto/widgets/chat_message_list.dart';
import 'package:yoto/stores/chat_store.dart';
import 'package:yoto/stores/match_store.dart';
import 'package:yoto/services/chat_timer_service.dart';

class ChatScreen extends StatefulWidget {
  final String chatId;
  final String friendId;
  final bool isFriend;

  const ChatScreen({
    Key? key,
    required this.chatId,
    required this.friendId,
    this.isFriend = false,
  }) : super(key: key);

  @override
  ChatScreenState createState() => ChatScreenState();
}

class ChatScreenState extends State<ChatScreen> {
  late ChatTimerService _timerService;
  bool _isNavigating = false;

  @override
  void initState() {
    super.initState();
    _timerService = ChatTimerService(
      isFriend: widget.isFriend,
      onTimerEnd: _endChat,
    );
    _loadMessages();
  }

  void _loadMessages() {
    WidgetsBinding.instance.addPostFrameCallback((_) {
      Provider.of<ChatStore>(context, listen: false)
          .loadMessages(widget.chatId);
    });
  }

  void _endChat() {
    if (!widget.isFriend) {
      Provider.of<MatchStore>(context, listen: false)
          .endChat(widget.chatId, widget.friendId);
      _navigateToHome();
    }
  }

  void _navigateToHome() {
    if (!_isNavigating) {
      _isNavigating = true;
      WidgetsBinding.instance.addPostFrameCallback((_) {
        Navigator.of(context).pushReplacementNamed('/home');
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final matchStore = Provider.of<MatchStore>(context);

    return Observer(
      builder: (_) {
        if (matchStore.isChatEnded && !_isNavigating) {
          _navigateToHome();
        }

        return Scaffold(
          appBar: _TimerAppBar(
            timerValueListenable: _timerService.secondsRemaining,
            builder: (context, secondsRemaining) {
              return ChatAppBar(
                friendId: widget.friendId,
                isFriend: widget.isFriend,
                timerValue: secondsRemaining,
                onEndChat: _endChat,
              );
            },
          ),
          body: Column(
            children: [
              Expanded(
                child: ChatMessageList(chatId: widget.chatId),
              ),
              ChatInputArea(chatId: widget.chatId, isFriend: widget.isFriend),
            ],
          ),
        );
      },
    );
  }

  @override
  void dispose() {
    _timerService.dispose();
    super.dispose();
  }
}

class _TimerAppBar extends StatelessWidget implements PreferredSizeWidget {
  final ValueListenable<int> timerValueListenable;
  final Widget Function(BuildContext, int) builder;

  const _TimerAppBar({
    Key? key,
    required this.timerValueListenable,
    required this.builder,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return ValueListenableBuilder<int>(
      valueListenable: timerValueListenable,
      builder: (context, value, child) => builder(context, value),
    );
  }

  @override
  Size get preferredSize => const Size.fromHeight(kToolbarHeight);
}


# lib/screens/friend_list_screen.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:yoto/stores/friend_store.dart';
import 'package:yoto/stores/chat_store.dart';
import 'package:yoto/stores/auth_store.dart';
import 'package:yoto/widgets/custome_chat_list_item.dart'; // Adjust the import based on your folder structure

class FriendListScreen extends StatefulWidget {
  const FriendListScreen({Key? key}) : super(key: key);

  @override
  FriendListScreenState createState() => FriendListScreenState();
}

class FriendListScreenState extends State<FriendListScreen> {
  bool _initialLoading = true;

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      final authStore = Provider.of<AuthStore>(context, listen: false);
      final friendStore = Provider.of<FriendStore>(context, listen: false);
      friendStore.loadFriends(authStore.currentUser!.uid).then((_) {
        if (mounted) {
          setState(() {
            _initialLoading = false;
          });
        }
      });
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Friends'),
      ),
      body: _initialLoading
          ? const Center(child: CircularProgressIndicator())
          : _buildFriendList(),
    );
  }

  Widget _buildFriendList() {
    return Consumer<FriendStore>(
      builder: (context, friendStore, child) {
        if (friendStore.isLoading) {
          return const Center(child: CircularProgressIndicator());
        }
        if (friendStore.error != null) {
          return Center(child: Text('Error: ${friendStore.error}'));
        }
        if (friendStore.friends.isEmpty) {
          return const Center(child: Text('No friends found.'));
        }
        return ListView.builder(
          itemCount: friendStore.sortedFriends.length,
          itemBuilder: (context, index) {
            final friend = friendStore.sortedFriends[index];
            return CustomChatListItem(
              friend: friend,
              onTap: () {
                // Navigate to the chat screen
                Navigator.of(context).pushNamed(
                  '/chat',
                  arguments: {
                    'chatId': friend.id, // This is your unique chat ID
                    'friendId': friend.id, // The friend's user ID
                    'isFriend': true
                  },
                );
              },
            );
          },
        );
      },
    );
  }
}


# lib/screens/home_screen.dart
import 'package:flutter/material.dart';
import 'package:yoto/screens/friend_list_screen.dart';
import 'package:yoto/screens/profile_screen.dart';
import 'package:yoto/screens/search_screen.dart';

class HomeScreen extends StatefulWidget {
  const HomeScreen({super.key});

  @override
  HomeScreenState createState() => HomeScreenState();
}

class HomeScreenState extends State<HomeScreen> {
  int _currentIndex = 0;
  final List<Widget> _screens = [
    // FriendsListScreen(),
    const FriendListScreen(),
    const SearchScreen(),
    const ProfileScreen(),
  ];

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: AnimatedSwitcher(
        duration: const Duration(milliseconds: 300),
        transitionBuilder: (Widget child, Animation<double> animation) {
          return FadeTransition(
            opacity: animation,
            child: child,
          );
        },
        child: _screens[_currentIndex],
      ),
      bottomNavigationBar: BottomNavigationBar(
        currentIndex: _currentIndex,
        onTap: (index) {
          setState(() {
            _currentIndex = index;
          });
        },
        items: const [
          BottomNavigationBarItem(
            icon: Icon(Icons.people_outline),
            activeIcon: Icon(Icons.people),
            label: 'Friends',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.search_outlined),
            activeIcon: Icon(Icons.search),
            label: 'Search',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.person_outline),
            activeIcon: Icon(Icons.person),
            label: 'Profile',
          ),
        ],
        selectedItemColor: Colors.black,
        unselectedItemColor: Colors.grey,
        showUnselectedLabels: true,
      ),
    );
  }
}


# lib/screens/profile_edit_screen.dart
import 'package:flutter/material.dart';
import 'package:firebase_storage/firebase_storage.dart';
import 'package:image_picker/image_picker.dart';
import 'package:provider/provider.dart';
import 'package:yoto/stores/profile_store.dart';
import 'package:yoto/stores/auth_store.dart';
import 'package:flutter_mobx/flutter_mobx.dart';
import 'dart:io';

class ProfileEditScreen extends StatefulWidget {
  final bool isNewUser;

  const ProfileEditScreen({Key? key, this.isNewUser = false}) : super(key: key);

  @override
  ProfileEditScreenState createState() => ProfileEditScreenState();
}

class ProfileEditScreenState extends State<ProfileEditScreen> {
  final _formKey = GlobalKey<FormState>();
  final _nameController = TextEditingController();
  final _bioController = TextEditingController();
  DateTime? _birthDate;
  String? _gender;
  XFile? _imageFile;
  String? _imageUrl;
  bool _isLoading = false;

  @override
  void initState() {
    super.initState();
    _loadUserData();
  }

  Future<void> _loadUserData() async {
    if (!mounted) return; // Add this check
    final profileStore = Provider.of<ProfileStore>(context, listen: false);
    if (profileStore.profileData != null) {
      if (!mounted) return; // Add this check
      setState(() {
        _nameController.text = profileStore.profileData!['displayName'] ?? '';
        _bioController.text = profileStore.profileData!['bio'] ?? '';
        _birthDate = (profileStore.profileData!['birthDate'] as DateTime?);
        _gender = profileStore.profileData!['gender'];
        _imageUrl = profileStore.profileData!['profileImageUrl'];
      });
    } else {
      await profileStore.fetchProfileData();
      if (!mounted) return; // Add this check
      setState(() {
        _nameController.text = profileStore.profileData!['displayName'] ?? '';
        _bioController.text = profileStore.profileData!['bio'] ?? '';
        _birthDate = (profileStore.profileData!['birthDate'] as DateTime?);
        _gender = profileStore.profileData!['gender'];
        _imageUrl = profileStore.profileData!['profileImageUrl'];
      });
    }
  }

  Future<void> _pickImage() async {
    final ImagePicker _picker = ImagePicker();
    final XFile? image = await _picker.pickImage(source: ImageSource.gallery);
    if (image != null) {
      setState(() {
        _imageFile = image;
      });
    }
  }

  Future<void> _saveProfile() async {
    if (_formKey.currentState!.validate()) {
      setState(() {
        _isLoading = true;
      });

      try {
        final profileStore = Provider.of<ProfileStore>(context, listen: false);
        final authStore = Provider.of<AuthStore>(context, listen: false);

        String? imageUrl = _imageUrl;
        if (_imageFile != null) {
          final ref = FirebaseStorage.instance
              .ref()
              .child('user_profiles/${authStore.currentUser!.uid}');
          await ref.putFile(File(_imageFile!.path));
          imageUrl = await ref.getDownloadURL();
        }

        final updatedData = {
          'displayName': _nameController.text,
          'bio': _bioController.text,
          'birthDate': _birthDate,
          'gender': _gender.toString().toLowerCase(),
          'profileImageUrl': imageUrl,
          'profileCompleted': true,
        };

        await profileStore.updateProfile(updatedData);

        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Profile updated successfully')),
        );

        Navigator.of(context).pop();
      } catch (e) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error updating profile: $e')),
        );
      } finally {
        setState(() {
          _isLoading = false;
        });
      }
    }
  }

  String? _validateAge(DateTime? birthDate) {
    if (birthDate == null) {
      return 'Please select a birth date';
    }

    final today = DateTime.now();
    final age = today.year - birthDate.year;
    final isBirthdayPassedThisYear = (today.month > birthDate.month) ||
        (today.month == birthDate.month && today.day >= birthDate.day);

    if (age > 18 || (age == 18 && isBirthdayPassedThisYear)) {
      return null; // User is 18 or older
    } else {
      return 'You must be at least 18 years old';
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Center(
          child: Text(widget.isNewUser ? 'Create Profile' : 'Edit Profile'),
        ),
        actions: [
          IconButton(
            icon: const Icon(Icons.cancel),
            onPressed: () => Navigator.of(context).pop(),
          ),
        ],
        leading: const SizedBox(width: 0, height: 0),
      ),
      body: Observer(
        builder: (_) {
          final profileStore = Provider.of<ProfileStore>(context);
          if (profileStore.profileData == null) {
            return const Center(child: CircularProgressIndicator());
          }
          return SingleChildScrollView(
            padding: const EdgeInsets.all(16.0),
            child: Form(
              key: _formKey,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  Center(
                    child: GestureDetector(
                      onTap: _pickImage,
                      child: Stack(
                        children: [
                          CircleAvatar(
                            radius: 60,
                            backgroundColor: Colors.grey[300],
                            backgroundImage: _imageFile != null
                                ? FileImage(File(_imageFile!.path))
                                : (_imageUrl != null
                                    ? NetworkImage(_imageUrl!)
                                    : null) as ImageProvider?,
                            child: _imageFile == null && _imageUrl == null
                                ? const Icon(Icons.add_a_photo,
                                    size: 50, color: Colors.white)
                                : null,
                          ),
                          const Positioned(
                            bottom: 0,
                            right: 0,
                            child: CircleAvatar(
                              radius: 20,
                              backgroundColor: Colors.white,
                              child: Icon(Icons.edit, color: Colors.black),
                            ),
                          ),
                        ],
                      ),
                    ),
                  ),
                  const SizedBox(height: 20),
                  TextFormField(
                    controller: _nameController,
                    decoration: InputDecoration(
                      labelText: 'Display Name',
                      prefixIcon: const Icon(Icons.person),
                      border: OutlineInputBorder(
                        borderRadius: BorderRadius.circular(10),
                      ),
                    ),
                    validator: (value) =>
                        value!.isEmpty ? 'Please enter a display name' : null,
                  ),
                  const SizedBox(height: 16),
                  TextFormField(
                    controller: _bioController,
                    decoration: InputDecoration(
                      labelText: 'Bio',
                      prefixIcon: const Icon(Icons.info),
                      border: OutlineInputBorder(
                        borderRadius: BorderRadius.circular(10),
                      ),
                    ),
                    maxLines: 3,
                  ),
                  const SizedBox(height: 16),
                  TextFormField(
                    readOnly: true,
                    onTap: () async {
                      final DateTime? picked = await showDatePicker(
                        context: context,
                        initialDate: _birthDate ?? DateTime.now(),
                        firstDate: DateTime(1900),
                        lastDate: DateTime.now(),
                      );
                      if (picked != null && picked != _birthDate) {
                        setState(() {
                          _birthDate = picked;
                        });
                      }
                    },
                    decoration: InputDecoration(
                      labelText: _birthDate == null
                          ? 'Select Birth Date'
                          : 'Birth Date: ${_birthDate!.toLocal().toString().split(' ')[0]}',
                      prefixIcon: const Icon(Icons.calendar_today),
                      suffixIcon: _birthDate != null
                          ? IconButton(
                              icon: const Icon(Icons.clear),
                              onPressed: () {
                                setState(() {
                                  _birthDate = null;
                                });
                              },
                            )
                          : null,
                      border: OutlineInputBorder(
                        borderRadius: BorderRadius.circular(10),
                      ),
                    ),
                  ),
                  const SizedBox(height: 16),
                  if (_birthDate != null)
                    Text(
                      _validateAge(_birthDate) ?? '',
                      style: const TextStyle(color: Colors.red, fontSize: 12),
                    ),
                  DropdownButtonFormField<String>(
                    value: _gender,
                    decoration: InputDecoration(
                      labelText: 'Gender',
                      prefixIcon: const Icon(Icons.wc),
                      border: OutlineInputBorder(
                        borderRadius: BorderRadius.circular(10),
                      ),
                    ),
                    items: ['Male', 'Female', 'Other']
                        .map((label) => DropdownMenuItem(
                              value: label,
                              child: Text(label),
                            ))
                        .toList(),
                    onChanged: (value) {
                      setState(() {
                        _gender = value;
                      });
                    },
                    validator: (value) =>
                        value == null ? 'Please select a gender' : null,
                  ),
                  const SizedBox(height: 24),
                  ElevatedButton(
                    style: ElevatedButton.styleFrom(
                      padding: const EdgeInsets.symmetric(vertical: 15),
                      shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(10),
                      ),
                    ),
                    onPressed: _isLoading
                        ? null
                        : () {
                            if (_formKey.currentState!.validate() &&
                                _validateAge(_birthDate) == null) {
                              _saveProfile();
                            }
                          },
                    child: _isLoading
                        ? const CircularProgressIndicator(
                            valueColor:
                                AlwaysStoppedAnimation<Color>(Colors.white),
                          )
                        : const Text('Save Profile'),
                  ),
                ],
              ),
            ),
          );
        },
      ),
    );
  }
}


# lib/screens/profile_screen.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:yoto/stores/profile_store.dart';
import 'package:yoto/stores/auth_store.dart';
import 'package:yoto/screens/profile_edit_screen.dart';
import 'package:flutter_mobx/flutter_mobx.dart';

class ProfileScreen extends StatelessWidget {
  final String? userId;

  const ProfileScreen({Key? key, this.userId}) : super(key: key);

  void _editProfile(BuildContext context) {
    Navigator.push(
      context,
      MaterialPageRoute(builder: (context) => const ProfileEditScreen()),
    );
  }

  void _logout(BuildContext context) async {
    final authStore = Provider.of<AuthStore>(context, listen: false);
    await authStore.signOut();
    Navigator.of(context).pushReplacementNamed('/auth');
  }

  @override
  Widget build(BuildContext context) {
    final profileStore = Provider.of<ProfileStore>(context);
    final authStore = Provider.of<AuthStore>(context);
    final isCurrentUser =
        userId == null || userId == authStore.currentUser?.uid;

    return Observer(
      builder: (_) => Scaffold(
        appBar: AppBar(
          title: Text(profileStore.profileData?['displayName'] ?? 'Profile'),
          leading: IconButton(
            icon: const Icon(Icons.arrow_back),
            onPressed: () => Navigator.of(context).pop(),
          ),
          actions: isCurrentUser
              ? [
                  IconButton(
                    icon: const Icon(Icons.logout),
                    onPressed: () => _logout(context),
                  ),
                ]
              : null,
        ),
        body: profileStore.profileData == null
            ? const Center(child: CircularProgressIndicator())
            : SingleChildScrollView(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.center,
                  children: [
                    Padding(
                      padding: const EdgeInsets.only(top: 20.0),
                      child: CircleAvatar(
                        radius: 60,
                        backgroundImage: NetworkImage(
                          profileStore.profileData!['profileImageUrl'] ??
                              'https://via.placeholder.com/400x200',
                        ),
                      ),
                    ),
                    const SizedBox(height: 16),
                    Text(
                      profileStore.profileData!['displayName'] ?? 'No Name',
                      style: const TextStyle(
                        fontSize: 24,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    const SizedBox(height: 8),
                    if (isCurrentUser)
                      Text(
                        authStore.currentUser?.email ?? 'No Email',
                        style: const TextStyle(
                          fontSize: 16,
                          color: Colors.grey,
                        ),
                      ),
                    const SizedBox(height: 30),
                    const Divider(),
                    ListTile(
                      title: const Text(
                        'Bio',
                        style: TextStyle(
                            fontSize: 16, fontWeight: FontWeight.bold),
                      ),
                      subtitle: Text(
                        profileStore.profileData!['bio'] ?? 'No bio available',
                        style: const TextStyle(fontSize: 16),
                      ),
                    ),
                    const Divider(),
                    ListTile(
                      leading: const Icon(Icons.cake, color: Colors.grey),
                      title: Text(
                        profileStore.profileData!['birthDate'] != null
                            ? 'Born ${(profileStore.profileData!['birthDate'] as DateTime).toString().split(' ')[0]}'
                            : 'Birth date not set',
                        style: const TextStyle(fontSize: 16),
                      ),
                    ),
                    ListTile(
                      leading: Icon(
                        profileStore.profileData!['gender'] == 'Male'
                            ? Icons.male
                            : Icons.female,
                        color: Colors.grey,
                      ),
                      title: Text(
                        profileStore.profileData!['gender'] ?? 'Gender not set',
                        style: const TextStyle(fontSize: 16),
                      ),
                    ),
                  ],
                ),
              ),
        floatingActionButton: isCurrentUser
            ? FloatingActionButton(
                onPressed: () => _editProfile(context),
                child: const Icon(Icons.edit),
              )
            : null,
      ),
    );
  }
}


# lib/screens/search_screen.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:geolocator/geolocator.dart';
import 'package:yoto/services/location_service.dart';
import 'package:yoto/widgets/search_animation.dart';
import 'package:yoto/widgets/search_button.dart';
import 'package:yoto/stores/match_store.dart';
import 'package:flutter_mobx/flutter_mobx.dart';

class SearchScreen extends StatefulWidget {
  const SearchScreen({Key? key}) : super(key: key);

  @override
  State<SearchScreen> createState() => _SearchScreenState();
}

class _SearchScreenState extends State<SearchScreen> {
  final LocationService _locationService = LocationService();
  Position? _currentPosition;

  @override
  void initState() {
    super.initState();
    _initializeLocation();
  }

  Future<void> _initializeLocation() async {
    _currentPosition = await _locationService.getCurrentLocation(context);
  }

  Future<void> startSearch(MatchStore matchStore) async {
    final userId = FirebaseAuth.instance.currentUser?.uid;
    if (userId == null) return;

    matchStore.setSearching(true);

    try {
      Map<String, dynamic> userData = {
        'userId': userId,
        if (_currentPosition != null)
          'location': {
            'latitude': _currentPosition!.latitude,
            'longitude': _currentPosition!.longitude,
          },
      };

      bool isAddedInQueue = await matchStore.addToMatchQueue(userData);
      if (isAddedInQueue) {
        matchStore.startListeningForMatches(
          userId,
          (String chatId, String otherUserId) {
            stopSearch(matchStore);
            Navigator.of(context).pushNamed('/anonymous_chat', arguments: {
              'chatId': chatId,
              'friendId': otherUserId,
            });
          },
        );
      }
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Error starting search: $e')),
      );
      matchStore.setSearching(false);
    }
  }

  Future<void> stopSearch(MatchStore matchStore) async {
    matchStore.setSearching(false);

    try {
      await matchStore.removeFromMatchQueue();
      matchStore.stopListeningForMatches();
    } catch (e) {
      print('Error stopping search: $e');
    }
  }

  @override
  Widget build(BuildContext context) {
    final matchStore = Provider.of<MatchStore>(context);

    return Scaffold(
      appBar: AppBar(
        title: const Text('Find a Match'),
      ),
      body: Center(
        child: Observer(
          builder: (_) => Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              if (matchStore.isSearching) const SearchAnimation(),
              const SizedBox(height: 20),
              SearchButton(
                isSearching: matchStore.isSearching,
                onStartSearch: () => startSearch(matchStore),
                onStopSearch: () => stopSearch(matchStore),
              ),
            ],
          ),
        ),
      ),
    );
  }

  @override
  void dispose() {
    final matchStore = Provider.of<MatchStore>(context, listen: false);
    matchStore.stopListeningForMatches();
    super.dispose();
  }
}


# lib/services/auth_service.dart
import 'package:firebase_auth/firebase_auth.dart';

class AuthService {
  final FirebaseAuth _auth = FirebaseAuth.instance;

  Future<User?> signIn(String email, String password) async {
    try {
      UserCredential result = await _auth.signInWithEmailAndPassword(
        email: email,
        password: password,
      );
      return result.user;
    } catch (e) {
      throw _handleAuthException(e);
    }
  }

  Future<User?> signUp(String email, String password) async {
    try {
      UserCredential result = await _auth.createUserWithEmailAndPassword(
        email: email,
        password: password,
      );
      return result.user;
    } catch (e) {
      throw _handleAuthException(e);
    }
  }

  String _handleAuthException(dynamic e) {
    if (e is FirebaseAuthException) {
      switch (e.code) {
        case 'user-not-found':
          return 'No user found with this email.';
        case 'wrong-password':
          return 'Wrong password provided.';
        case 'email-already-in-use':
          return 'The email address is already in use.';
        default:
          return 'An error occurred. Please try again.';
      }
    }
    return 'An unexpected error occurred.';
  }

  String? validateEmail(String? value) {
    if (value?.isEmpty ?? true) {
      return 'Please enter your email';
    }
    final emailRegex = RegExp(r'^[\w-]+(\.[\w-]+)*@([\w-]+\.)+[a-zA-Z]{2,7}$');
    if (!emailRegex.hasMatch(value!)) {
      return 'Please enter a valid email address';
    }
    return null;
  }

  String? validatePassword(String? value) {
    if (value?.isEmpty ?? true) {
      return 'Please enter your password';
    }
    if (value!.length < 6) {
      return 'Password should be at least 6 characters';
    }
    return null;
  }
}

# lib/services/chat_timer_service.dart
import 'dart:async';
import 'package:flutter/foundation.dart';

class ChatTimerService {
  final bool isFriend;
  final VoidCallback onTimerEnd;
  Timer? _timer;
  final ValueNotifier<int> _secondsRemaining = ValueNotifier(15 * 60); // 15 minutes for anonymous chat

  ChatTimerService({required this.isFriend, required this.onTimerEnd}) {
    if (!isFriend) {
      _startTimer();
    }
  }

  ValueNotifier<int> get secondsRemaining => _secondsRemaining;

  void _startTimer() {
    _timer = Timer.periodic(const Duration(seconds: 1), (timer) {
      if (_secondsRemaining.value > 0) {
        _secondsRemaining.value--;
      } else {
        onTimerEnd();
        _timer?.cancel();
      }
    });
  }

  void dispose() {
    _timer?.cancel();
    _secondsRemaining.dispose();
  }
}

# lib/services/firestore_service.dart
import 'package:cloud_firestore/cloud_firestore.dart';

class FirestoreService {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;

  // Match-related operations
  Stream<QuerySnapshot> getChatStream(String userId) {
    return _firestore
        .collection('chats-v2')
        .where('users', arrayContains: userId)
        .snapshots();
  }

  // Friend-related operations
  Stream<DocumentSnapshot> getFriendsStream(String userId) {
    print('loading friends from $userId user');
    return _firestore.collection('friends').doc(userId).snapshots();
  }
}


# lib/services/graphql_service.dart
import 'dart:convert';
import 'package:http/http.dart' as http;
import 'package:firebase_auth/firebase_auth.dart';

class Graphqlservice {
  static const String url =
      'https://d9cuoxk4x9.execute-api.ap-south-1.amazonaws.com/Prod/graphql/';

  static Future<String?> _getToken() async {
    final FirebaseAuth _auth = FirebaseAuth.instance;
    final User? user = _auth.currentUser;
    return await user?.getIdToken();
  }

  static Future<Map<String, dynamic>?> _sendRequest(String query,
      {Map<String, dynamic>? variables}) async {
    final String? token = await _getToken();

    if (token == null) {
      throw Exception('User not authenticated');
    }

    print('Token (first 10 chars): ${token.substring(0, 10)}...');

    final headers = {
      'Content-Type': 'application/json',
      'Authorization': 'Bearer $token'
    };

    final body = jsonEncode({'query': query, 'variables': variables ?? {}});

    final response = await http.post(
      Uri.parse(url),
      headers: headers,
      body: body,
    );

    if (response.statusCode == 200) {
      return jsonDecode(response.body);
    } else {
      return null;
    }
  }

  Future<Map<String, dynamic>?> getUserProfile() async {
    const String query = '''
      query {
        getUserProfile {
          displayName
          bio
          profileCompleted
          birthDate
          profileImageUrl
          gender
        }
      }
    ''';

    final result = await _sendRequest(query);

    if (result == null || result['errors'] != null) {
      print('GraphQL query error: ${result?['errors']}');
      return null;
    }

    if (result['data'] == null || result['data']['getUserProfile'] == null) {
      print('No data returned from the query');
      return null;
    }

    final Map<String, dynamic> userProfile = result['data']['getUserProfile'];

    // Transform the data into the desired shape
    Map<String, dynamic> transformedProfile = {
      'profileImageUrl': userProfile['profileImageUrl'],
      'gender': userProfile['gender'] == 'female' ? 'Female' : 'Male',
      'displayName': userProfile['displayName'],
      'profileCompleted': userProfile['profileCompleted'],
      'bio': userProfile['bio'],
      'birthDate': _formatDate(userProfile['birthDate']),
    };
    print('Transformed profile: $transformedProfile');
    return transformedProfile;
  }

  Future<Map<String, dynamic>?> getFriendProfile(String friendId) async {
    final String query = '''
      query {
        getFriendProfile(friendId: "$friendId") {
          displayName
          bio
          profileCompleted
          birthDate
          profileImageUrl
          gender
        }
      }
    ''';

    final result = await _sendRequest(query);

    if (result == null || result['errors'] != null) {
      print('GraphQL query error: ${result?['errors']}');
      return null;
    }

    if (result['data'] == null || result['data']['getFriendProfile'] == null) {
      print('No data returned from the query');
      return null;
    }

    final Map<String, dynamic> friendProfile =
        result['data']['getFriendProfile'];

    // Transform the data into the desired shape
    Map<String, dynamic> transformedProfile = {
      'profileImageUrl': friendProfile['profileImageUrl'],
      'gender': friendProfile['gender'] == 'female' ? 'Female' : 'Male',
      'displayName': friendProfile['displayName'],
      'profileCompleted': friendProfile['profileCompleted'],
      'bio': friendProfile['bio'],
      'birthDate': _formatDate(friendProfile['birthDate']),
    };
    print('Transformed profile: $transformedProfile');
    return transformedProfile;
  }

  String _formatDate(String timestamp) {
    DateTime date = DateTime.fromMillisecondsSinceEpoch(int.parse(timestamp));
    return '${date.year}-${date.month.toString().padLeft(2, '0')}-${date.day.toString().padLeft(2, '0')}';
  }
}


# lib/services/location_service.dart
import 'package:flutter/material.dart';
import 'package:geolocator/geolocator.dart';

class LocationService {
  Future<Position?> getCurrentLocation(BuildContext context) async {
    bool serviceEnabled;
    LocationPermission permission;

    serviceEnabled = await Geolocator.isLocationServiceEnabled();
    if (!serviceEnabled) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
            content: Text(
                'Location services are disabled. Please enable the services')),
      );
      return null;
    }

    permission = await Geolocator.checkPermission();
    if (permission == LocationPermission.denied) {
      permission = await Geolocator.requestPermission();
      if (permission == LocationPermission.denied) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Location permissions are denied')),
        );
        return null;
      }
    }

    if (permission == LocationPermission.deniedForever) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
            content: Text(
                'Location permissions are permanently denied, we cannot request permissions.')),
      );
      return null;
    }

    try {
      return await Geolocator.getCurrentPosition();
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Error getting location: $e')),
      );
      return null;
    }
  }
}

# lib/services/serverless_service.dart
import 'dart:async';
import 'package:intl/intl.dart'; // Make sure to add this package to your pubspec.yaml
import 'package:http/http.dart' as http;
import 'dart:convert';
import 'package:firebase_auth/firebase_auth.dart';

class ServerlessService {
  final String baseUrl =
      'https://d9cuoxk4x9.execute-api.ap-south-1.amazonaws.com/Prod';

  final FirebaseAuth _auth = FirebaseAuth.instance;
  Future<String?> _getIdToken() async {
    User? user = _auth.currentUser;
    if (user != null) {
      return await user.getIdToken();
    }
    return null;
  }

  Future<void> updateProfile(Map<String, dynamic> userData,
      {bool isNew = false}) async {
    try {
      userData['isNew'] = isNew;

      Map<String, dynamic> sanitizedUserData = userData.map((key, value) {
        if (value is DateTime) {
          return MapEntry(key, DateFormat('yyyy-MM-dd').format(value));
        }
        return MapEntry(key, value);
      });

      String? idToken = await _getIdToken();
      if (idToken == null) {
        throw Exception('User not authenticated');
      }

      print(json.encode(sanitizedUserData));

      final Uri uri = Uri.parse('$baseUrl/userProfile/');

      final response = await http
          .post(
        uri,
        headers: {
          'Content-Type': 'application/json',
          'Access-Control-Allow-Origin': '*',
          'Authorization': 'Bearer $idToken',
        },
        body: json.encode(sanitizedUserData),
      )
          .timeout(Duration(seconds: 30), onTimeout: () {
        throw TimeoutException(
            'The connection has timed out, please try again.');
      });

      if (response.statusCode != 200) {
        throw Exception(
            'Failed to ${isNew ? 'create' : 'update'}: ${response.body}');
      }
    } catch (e, stackTrace) {
      print('Error in updateProfile: $e');
      print('Stack trace: $stackTrace');
      rethrow; // Re-throw the exception after logging
    }
  }

  Future<bool> addToMatchQueue(Map<String, dynamic> userData) async {
    try {
      String? idToken = await _getIdToken();
      if (idToken == null) {
        throw Exception('User not authenticated');
      }

      final response = await http.post(
        Uri.parse('$baseUrl/addToMatchQueue'),
        headers: {
          'Content-Type': 'application/json',
          'Access-Control-Allow-Origin': '*', // Allow all origins
          'Authorization': 'Bearer $idToken',
        },
        body: json.encode(userData),
      );
      if (response.statusCode == 200) {
        return true;
      }
      return false;
    } catch (e) {
      print('error $e');
      return false;
    }
  }

  Future<void> removeFromMatchQueue() async {
    String? idToken = await _getIdToken();
    if (idToken == null) {
      throw Exception('User not authenticated');
    }

    final response = await http.post(
      Uri.parse('$baseUrl/removeFromMatchQueue'),
      headers: {
        'Content-Type': 'application/json',
        'Access-Control-Allow-Origin': '*', // Allow all origins
        'Authorization': 'Bearer $idToken',
      },
    );

    if (response.statusCode != 200) {
      throw Exception('Failed to remove from match queue: ${response.body}');
    }
  }
}


# lib/services/socket_service.dart
import 'package:socket_io_client/socket_io_client.dart' as IO;

class SocketService {
  late IO.Socket socket;

  SocketService() {
    _initSocket();
  }

  void _initSocket() {
    socket = IO.io('https://f7e2-2409-40c1-10fa-cfbd-51c2-d311-efc1-d768.ngrok-free.app', <String, dynamic>{
      'transports': ['websocket'],
      'autoConnect': false,
    });

    socket.connect();

    socket.onConnect((_) {
      print('Socket connection established');
    });

    socket.onDisconnect((_) {
      print('Socket disconnected');
    });

    socket.onError((error) {
      print('Socket error: $error');
    });
  }

  void emit(String event, dynamic data) {
    socket.emit(event, data);
  }

  void on(String event, Function(dynamic) handler) {
    socket.on(event, handler);
  }

  void off(String event) {
    socket.off(event);
  }

  void disconnect() {
    socket.disconnect();
  }

  bool get isConnected => socket.connected;
}


# lib/stores/auth_store.dart
import 'package:mobx/mobx.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:yoto/services/auth_service.dart';
import 'package:shared_preferences/shared_preferences.dart';

part 'auth_store.g.dart';

class AuthStore = _AuthStore with _$AuthStore;

abstract class _AuthStore with Store {
  final AuthService _authService = AuthService();
  final String _cacheKey = 'auth_cache';

  @observable
  User? currentUser;

  @computed
  bool get isLoggedIn => currentUser != null;

  @action
  Future<void> signIn(String email, String password) async {
    try {
      currentUser = await _authService.signIn(email, password);
      if (currentUser != null) {
        await _saveToCache();
      }
    } catch (e) {
      throw e.toString();
    }
  }

  @action
  Future<void> signUp(String email, String password) async {
    try {
      currentUser = await _authService.signUp(email, password);
      if (currentUser != null) {
        await _saveToCache();
      }
    } catch (e) {
      throw e.toString();
    }
  }

  @action
  Future<void> signOut() async {
    await FirebaseAuth.instance.signOut();
    currentUser = null;
    await _clearCache();
  }

  @action
  Future<void> init() async {
    currentUser = FirebaseAuth.instance.currentUser;
    if (currentUser == null) {
      await _loadFromCache();
    }
  }

  Future<void> _saveToCache() async {
    final prefs = await SharedPreferences.getInstance();
    if (currentUser != null) {
      await prefs.setString(_cacheKey, currentUser!.uid);
    }
  }

  Future<void> _loadFromCache() async {
    final prefs = await SharedPreferences.getInstance();
    final String? cachedUid = prefs.getString(_cacheKey);
    if (cachedUid != null) {
      currentUser = await FirebaseAuth.instance.userChanges().first;
    }
  }

  Future<void> _clearCache() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.remove(_cacheKey);
  }

  String? validateEmail(String? value) {
    return _authService.validateEmail(value);
  }

  String? validatePassword(String? value) {
    return _authService.validatePassword(value);
  }
}


# lib/stores/auth_store.g.dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'auth_store.dart';

// **************************************************************************
// StoreGenerator
// **************************************************************************

// ignore_for_file: non_constant_identifier_names, unnecessary_brace_in_string_interps, unnecessary_lambdas, prefer_expression_function_bodies, lines_longer_than_80_chars, avoid_as, avoid_annotating_with_dynamic, no_leading_underscores_for_local_identifiers

mixin _$AuthStore on _AuthStore, Store {
  Computed<bool>? _$isLoggedInComputed;

  @override
  bool get isLoggedIn => (_$isLoggedInComputed ??=
          Computed<bool>(() => super.isLoggedIn, name: '_AuthStore.isLoggedIn'))
      .value;

  late final _$currentUserAtom =
      Atom(name: '_AuthStore.currentUser', context: context);

  @override
  User? get currentUser {
    _$currentUserAtom.reportRead();
    return super.currentUser;
  }

  @override
  set currentUser(User? value) {
    _$currentUserAtom.reportWrite(value, super.currentUser, () {
      super.currentUser = value;
    });
  }

  late final _$signInAsyncAction =
      AsyncAction('_AuthStore.signIn', context: context);

  @override
  Future<void> signIn(String email, String password) {
    return _$signInAsyncAction.run(() => super.signIn(email, password));
  }

  late final _$signUpAsyncAction =
      AsyncAction('_AuthStore.signUp', context: context);

  @override
  Future<void> signUp(String email, String password) {
    return _$signUpAsyncAction.run(() => super.signUp(email, password));
  }

  late final _$signOutAsyncAction =
      AsyncAction('_AuthStore.signOut', context: context);

  @override
  Future<void> signOut() {
    return _$signOutAsyncAction.run(() => super.signOut());
  }

  late final _$initAsyncAction =
      AsyncAction('_AuthStore.init', context: context);

  @override
  Future<void> init() {
    return _$initAsyncAction.run(() => super.init());
  }

  @override
  String toString() {
    return '''
currentUser: ${currentUser},
isLoggedIn: ${isLoggedIn}
    ''';
  }
}


# lib/stores/chat_store.dart
import 'package:mobx/mobx.dart';
import 'package:flutter_chat_types/flutter_chat_types.dart' as types;
import 'package:yoto/services/socket_service.dart';

part 'chat_store.g.dart';

class ChatStore = _ChatStore with _$ChatStore;

abstract class _ChatStore with Store {
  final SocketService _socketService;

  _ChatStore(this._socketService) {
    _initSocketListeners();
  }

  @observable
  ObservableMap<String, ObservableList<types.Message>> chatMessages =
      ObservableMap();

  @observable
  String? currentChatType;

  void _initSocketListeners() {
    _socketService
      ..on('new_message', _handleNewMessage)
      ..on('chat_history', _handleChatHistory)
      ..on('chat_type', _handleChatType)
      ..on('friend_request_accepted', _handleFriendRequestAccepted);
  }

  types.TextMessage _createMessage(dynamic msgData) {
    print('msgData $msgData');
    return types.TextMessage(
      author: types.User(id: msgData['senderId']),
      id: msgData['id'],
      text: msgData['text'],
      createdAt: msgData['createdAt'] as int,
    );
  }

  List<types.Message> getMessagesForChat(String chatId) =>
      chatMessages[chatId] ?? [];

  void dispose() {
    _socketService
      ..off('new_message')
      ..off('chat_history')
      ..off('chat_type')
      ..off('friend_request_accepted');
  }

  @action
  void registerUser(String userId) =>
      _socketService.emit('register_user', userId);

  @action
  void _handleNewMessage(dynamic data) {
    print('event listener called with data $data');
    final chatId = data['chatId'];
    final message = _createMessage(data);
    chatMessages
        .putIfAbsent(chatId, () => ObservableList<types.Message>())
        .insert(0, message);
  }

  @action
  void _handleChatHistory(dynamic data) {
    final chatId = data['chatId'];
    final messages = (data['messages'] as List).map(_createMessage).toList();
    chatMessages[chatId] = ObservableList.of(messages);
  }

  @action
  void _handleChatType(dynamic data) {
    currentChatType = data['type'];
  }

  @action
  void _handleFriendRequestAccepted(dynamic data) {
    // Handle friend request accepted event
    // You might want to update UI or perform some action here
    print('Friend request accepted for chat: ${data['chatId']}');
  }

  @action
  Future<void> loadMessages(String chatId) async {
    _socketService.emit('join_chat', chatId);
    _socketService.emit('get_chat_history', {'chatId': chatId});
    _socketService.emit('get_chat_type', {'chatId': chatId});
  }

  @action
  Future<void> sendMessage(String chatId, String text, String senderId) async {
    final message = {
      'chatId': chatId,
      'senderId': senderId,
      'text': text,
    };

    _socketService.emit('send_message', message);

    // Optimistically add the message to the local list
    final localMessage = types.TextMessage(
      author: types.User(id: senderId),
      id: DateTime.now().millisecondsSinceEpoch.toString(),
      text: text,
      createdAt: DateTime.now().millisecondsSinceEpoch,
    );

    chatMessages
        .putIfAbsent(chatId, () => ObservableList<types.Message>())
        .insert(0, localMessage);
  }

  @action
  Future<void> sendFriendRequest(String chatId, String userId) async {
    _socketService.emit('add_friend', {'userId': userId, 'chatId': chatId});
  }

  @action
  Future<void> endChat(String chatId, String userId) async {
    _socketService.emit('end_chat', {'chatId': chatId, 'userId': userId});
  }

  @action
  Future<void> convertToPermanent(
      String anonymousChatId, String permanentChatId) async {
    _socketService.emit('convert_to_permanent', {
      'anonymousChatId': anonymousChatId,
      'permanentChatId': permanentChatId
    });
  }
}


# lib/stores/chat_store.g.dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'chat_store.dart';

// **************************************************************************
// StoreGenerator
// **************************************************************************

// ignore_for_file: non_constant_identifier_names, unnecessary_brace_in_string_interps, unnecessary_lambdas, prefer_expression_function_bodies, lines_longer_than_80_chars, avoid_as, avoid_annotating_with_dynamic, no_leading_underscores_for_local_identifiers

mixin _$ChatStore on _ChatStore, Store {
  late final _$chatMessagesAtom =
      Atom(name: '_ChatStore.chatMessages', context: context);

  @override
  ObservableMap<String, ObservableList<types.Message>> get chatMessages {
    _$chatMessagesAtom.reportRead();
    return super.chatMessages;
  }

  @override
  set chatMessages(ObservableMap<String, ObservableList<types.Message>> value) {
    _$chatMessagesAtom.reportWrite(value, super.chatMessages, () {
      super.chatMessages = value;
    });
  }

  late final _$currentChatTypeAtom =
      Atom(name: '_ChatStore.currentChatType', context: context);

  @override
  String? get currentChatType {
    _$currentChatTypeAtom.reportRead();
    return super.currentChatType;
  }

  @override
  set currentChatType(String? value) {
    _$currentChatTypeAtom.reportWrite(value, super.currentChatType, () {
      super.currentChatType = value;
    });
  }

  late final _$loadMessagesAsyncAction =
      AsyncAction('_ChatStore.loadMessages', context: context);

  @override
  Future<void> loadMessages(String chatId) {
    return _$loadMessagesAsyncAction.run(() => super.loadMessages(chatId));
  }

  late final _$sendMessageAsyncAction =
      AsyncAction('_ChatStore.sendMessage', context: context);

  @override
  Future<void> sendMessage(String chatId, String text, String senderId) {
    return _$sendMessageAsyncAction
        .run(() => super.sendMessage(chatId, text, senderId));
  }

  late final _$sendFriendRequestAsyncAction =
      AsyncAction('_ChatStore.sendFriendRequest', context: context);

  @override
  Future<void> sendFriendRequest(String chatId, String userId) {
    return _$sendFriendRequestAsyncAction
        .run(() => super.sendFriendRequest(chatId, userId));
  }

  late final _$endChatAsyncAction =
      AsyncAction('_ChatStore.endChat', context: context);

  @override
  Future<void> endChat(String chatId, String userId) {
    return _$endChatAsyncAction.run(() => super.endChat(chatId, userId));
  }

  late final _$convertToPermanentAsyncAction =
      AsyncAction('_ChatStore.convertToPermanent', context: context);

  @override
  Future<void> convertToPermanent(
      String anonymousChatId, String permanentChatId) {
    return _$convertToPermanentAsyncAction
        .run(() => super.convertToPermanent(anonymousChatId, permanentChatId));
  }

  late final _$_ChatStoreActionController =
      ActionController(name: '_ChatStore', context: context);

  @override
  void registerUser(String userId) {
    final _$actionInfo = _$_ChatStoreActionController.startAction(
        name: '_ChatStore.registerUser');
    try {
      return super.registerUser(userId);
    } finally {
      _$_ChatStoreActionController.endAction(_$actionInfo);
    }
  }

  @override
  void _handleNewMessage(dynamic data) {
    final _$actionInfo = _$_ChatStoreActionController.startAction(
        name: '_ChatStore._handleNewMessage');
    try {
      return super._handleNewMessage(data);
    } finally {
      _$_ChatStoreActionController.endAction(_$actionInfo);
    }
  }

  @override
  void _handleChatHistory(dynamic data) {
    final _$actionInfo = _$_ChatStoreActionController.startAction(
        name: '_ChatStore._handleChatHistory');
    try {
      return super._handleChatHistory(data);
    } finally {
      _$_ChatStoreActionController.endAction(_$actionInfo);
    }
  }

  @override
  void _handleChatType(dynamic data) {
    final _$actionInfo = _$_ChatStoreActionController.startAction(
        name: '_ChatStore._handleChatType');
    try {
      return super._handleChatType(data);
    } finally {
      _$_ChatStoreActionController.endAction(_$actionInfo);
    }
  }

  @override
  void _handleFriendRequestAccepted(dynamic data) {
    final _$actionInfo = _$_ChatStoreActionController.startAction(
        name: '_ChatStore._handleFriendRequestAccepted');
    try {
      return super._handleFriendRequestAccepted(data);
    } finally {
      _$_ChatStoreActionController.endAction(_$actionInfo);
    }
  }

  @override
  String toString() {
    return '''
chatMessages: ${chatMessages},
currentChatType: ${currentChatType}
    ''';
  }
}


# lib/stores/friend_store.dart
import 'package:mobx/mobx.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:yoto/services/firestore_service.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'dart:convert';

import 'package:yoto/services/graphql_service.dart';

part 'friend_store.g.dart';

class FriendStore = _FriendStore with _$FriendStore;

abstract class _FriendStore with Store {
  final FirestoreService _firestoreService;
  final Graphqlservice _graphqlservice;
  final String _cacheKey = 'friends_cache';

  _FriendStore(this._firestoreService, this._graphqlservice);

  @observable
  ObservableMap<String, Friend> friends = ObservableMap<String, Friend>();

  @observable
  bool isLoading = false;

  @observable
  String? error;

  @computed
  List<Friend> get sortedFriends {
    final List<Friend> sortedList = friends.values.toList();
    sortedList.sort((a, b) => b.lastMessageTime.compareTo(a.lastMessageTime));
    return sortedList;
  }

  @action
  Future<void> loadFriends(String userId) async {
    print("loadFriends called for user: $userId");

    isLoading = true;
    error = null;

    try {
      print("Attempting to load from cache");
      await _loadFromCache();

      print("Getting friends stream for user: $userId");
      final stream = _firestoreService.getFriendsStream(userId);

      print("Waiting for first value from stream");
      final initialSnapshot = await stream.first;
      print(
          "Received initial snapshot: ${initialSnapshot.exists ? "exists" : "does not exist"}");

      if (!initialSnapshot.exists) {
        print("No friends data found for user: $userId");
        friends.clear();
      } else {
        print("Updating friends from initial snapshot");
        _updateFriendsFromSnapshot(initialSnapshot);
      }

      print("Setting up stream listener");
      stream.listen(
        (snapshot) {
          print(
              "Received snapshot from stream: ${snapshot.exists ? "exists" : "does not exist"}");
          if (snapshot.exists) {
            print("Updating friends from snapshot");
            _updateFriendsFromSnapshot(snapshot);
            _saveToCache();
          } else {
            print("Snapshot does not exist, clearing friends");
            friends.clear();
          }
        },
        onError: (e) {
          print("Error in Firestore stream: $e");
          error = 'Failed to load friends: $e';
          isLoading = false;
        },
      );
    } catch (e) {
      print("Error in loadFriends: $e");
      error = 'Failed to load friends: $e';
    } finally {
      isLoading = false;
    }
  }

  @action
  Future<void> _loadFromCache() async {
    final prefs = await SharedPreferences.getInstance();
    final String? cachedData = prefs.getString(_cacheKey);
    if (cachedData != null) {
      final List<dynamic> decoded = jsonDecode(cachedData);
      friends = ObservableMap.of(Map.fromEntries(decoded.map((item) {
        final friend = Friend.fromJson(item);
        return MapEntry(friend.id, friend);
      })));
    }
  }

  @action
  Future<void> _saveToCache() async {
    final prefs = await SharedPreferences.getInstance();
    final encoded = jsonEncode(friends.values.toList());
    await prefs.setString(_cacheKey, encoded);
  }

  @action
  void _updateFriendsFromSnapshot(DocumentSnapshot snapshot) {
    final friendsData = snapshot.data() as Map<String, dynamic>?;

    if (friendsData != null) {
      friends = ObservableMap.of(friendsData.map((key, value) {
        return MapEntry(
          key,
          Friend(
            id: key,
            chatId: value['chatId'],
            displayName: value['displayName'] ?? 'Unknown User',
            profileImageUrl: value['profileImageUrl'],
            lastMessage: value['lastMessage'] ?? 'No messages yet',
            lastMessageTime: value['lastMessageTime'] is Timestamp
                ? value['lastMessageTime']
                : Timestamp.fromMillisecondsSinceEpoch(
                    value['lastMessageTime'] ?? 0),
            unreadCount: value['unreadCount'] ?? 0,
          ),
        );
      }));
    } else {
      print("No friends data in snapshot");
      friends.clear();
    }
  }

  @action
  Future<Map<String, dynamic>?> getFriendProfile(String friendId) async {
    return await _graphqlservice.getFriendProfile(friendId);
  }
}

class Friend {
  final String id;
  final String chatId;
  final String displayName;
  final String? profileImageUrl;
  final String lastMessage;
  final Timestamp lastMessageTime;
  final int unreadCount;

  Friend({
    required this.id,
    required this.chatId,
    required this.displayName,
    this.profileImageUrl,
    required this.lastMessage,
    required this.lastMessageTime,
    required this.unreadCount,
  });

  factory Friend.fromJson(Map<String, dynamic> json) {
    return Friend(
      id: json['id'],
      chatId: json['chatId'],
      displayName: json['displayName'],
      profileImageUrl: json['profileImageUrl'],
      lastMessage: json['lastMessage'],
      lastMessageTime:
          Timestamp.fromMillisecondsSinceEpoch(json['lastMessageTime']),
      unreadCount: json['unreadCount'],
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'chatId': chatId,
      'displayName': displayName,
      'profileImageUrl': profileImageUrl,
      'lastMessage': lastMessage,
      'lastMessageTime': lastMessageTime.millisecondsSinceEpoch,
      'unreadCount': unreadCount,
    };
  }
}


# lib/stores/friend_store.g.dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'friend_store.dart';

// **************************************************************************
// StoreGenerator
// **************************************************************************

// ignore_for_file: non_constant_identifier_names, unnecessary_brace_in_string_interps, unnecessary_lambdas, prefer_expression_function_bodies, lines_longer_than_80_chars, avoid_as, avoid_annotating_with_dynamic, no_leading_underscores_for_local_identifiers

mixin _$FriendStore on _FriendStore, Store {
  Computed<List<Friend>>? _$sortedFriendsComputed;

  @override
  List<Friend> get sortedFriends => (_$sortedFriendsComputed ??=
          Computed<List<Friend>>(() => super.sortedFriends,
              name: '_FriendStore.sortedFriends'))
      .value;

  late final _$friendsAtom =
      Atom(name: '_FriendStore.friends', context: context);

  @override
  ObservableMap<String, Friend> get friends {
    _$friendsAtom.reportRead();
    return super.friends;
  }

  @override
  set friends(ObservableMap<String, Friend> value) {
    _$friendsAtom.reportWrite(value, super.friends, () {
      super.friends = value;
    });
  }

  late final _$isLoadingAtom =
      Atom(name: '_FriendStore.isLoading', context: context);

  @override
  bool get isLoading {
    _$isLoadingAtom.reportRead();
    return super.isLoading;
  }

  @override
  set isLoading(bool value) {
    _$isLoadingAtom.reportWrite(value, super.isLoading, () {
      super.isLoading = value;
    });
  }

  late final _$errorAtom = Atom(name: '_FriendStore.error', context: context);

  @override
  String? get error {
    _$errorAtom.reportRead();
    return super.error;
  }

  @override
  set error(String? value) {
    _$errorAtom.reportWrite(value, super.error, () {
      super.error = value;
    });
  }

  late final _$loadFriendsAsyncAction =
      AsyncAction('_FriendStore.loadFriends', context: context);

  @override
  Future<void> loadFriends(String userId) {
    return _$loadFriendsAsyncAction.run(() => super.loadFriends(userId));
  }

  late final _$_loadFromCacheAsyncAction =
      AsyncAction('_FriendStore._loadFromCache', context: context);

  @override
  Future<void> _loadFromCache() {
    return _$_loadFromCacheAsyncAction.run(() => super._loadFromCache());
  }

  late final _$_saveToCacheAsyncAction =
      AsyncAction('_FriendStore._saveToCache', context: context);

  @override
  Future<void> _saveToCache() {
    return _$_saveToCacheAsyncAction.run(() => super._saveToCache());
  }

  late final _$getFriendProfileAsyncAction =
      AsyncAction('_FriendStore.getFriendProfile', context: context);

  @override
  Future<Map<String, dynamic>?> getFriendProfile(String friendId) {
    return _$getFriendProfileAsyncAction
        .run(() => super.getFriendProfile(friendId));
  }

  late final _$_FriendStoreActionController =
      ActionController(name: '_FriendStore', context: context);

  @override
  void _updateFriendsFromSnapshot(DocumentSnapshot<Object?> snapshot) {
    final _$actionInfo = _$_FriendStoreActionController.startAction(
        name: '_FriendStore._updateFriendsFromSnapshot');
    try {
      return super._updateFriendsFromSnapshot(snapshot);
    } finally {
      _$_FriendStoreActionController.endAction(_$actionInfo);
    }
  }

  @override
  String toString() {
    return '''
friends: ${friends},
isLoading: ${isLoading},
error: ${error},
sortedFriends: ${sortedFriends}
    ''';
  }
}


# lib/stores/match_store.dart
import 'dart:async';
import 'package:mobx/mobx.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:yoto/services/serverless_service.dart';
import 'package:yoto/services/socket_service.dart';
import 'package:yoto/services/firestore_service.dart';

part 'match_store.g.dart';

class MatchStore = _MatchStore with _$MatchStore;

abstract class _MatchStore with Store {
  final ServerlessService _serverlessService;
  final FirestoreService _firestoreService;
  final SocketService _socketService;

  _MatchStore(
      this._socketService, this._serverlessService, this._firestoreService) {
    _initSocketListeners();
  }

  @observable
  bool isInQueue = false;

  @observable
  bool isSearching = false;

  @observable
  bool isChatEnded = false;

  @observable
  bool areFriendsNow = false;

  @observable
  DateTime? lastListenStartTime;

  @observable
  StreamSubscription<QuerySnapshot>? _matchListener;

  @observable
  Map<String, dynamic>? currentMatch;

  void _initSocketListeners() {
    _socketService
      ..on('chat_ended', _handleChatEnded)
      ..on('friend_request_accepted', _handleFriendRequestAccepted);
  }

  @action
  void setInQueue(bool value) => isInQueue = value;

  @action
  void setSearching(bool value) {
    isSearching = value;
    if (!value) stopListeningForMatches();
  }

  @action
  void resetMatchState() {
    isChatEnded = false;
    areFriendsNow = false;
  }

  @action
  Future<bool> addToMatchQueue(Map<String, dynamic> userData) async {
    bool isAddedInQueue = await _serverlessService.addToMatchQueue(userData);
    setInQueue(isAddedInQueue);
    return isAddedInQueue;
  }

  @action
  Future<void> removeFromMatchQueue() async {
    await _serverlessService.removeFromMatchQueue();
    setInQueue(false);
  }

  @action
  void startListeningForMatches(
      String userId, Function(String, String) onMatchFound) {
    stopListeningForMatches();
    resetMatchState();
    lastListenStartTime = DateTime.now();

    _matchListener = _firestoreService.getChatStream(userId).listen(
          (snapshot) => _processSnapshot(snapshot, userId, onMatchFound),
          onError: (error) => print("Error in match listener: $error"),
        );
  }

  @action
  void stopListeningForMatches() {
    _matchListener?.cancel();
    _matchListener = null;
    lastListenStartTime = null;
  }

  void _processSnapshot(QuerySnapshot snapshot, String userId,
      Function(String, String) onMatchFound) {
    for (var change in snapshot.docChanges) {
      if (change.type == DocumentChangeType.added) {
        _handleNewMatch(change.doc, userId, onMatchFound);
      }
    }
  }

  void _handleNewMatch(DocumentSnapshot doc, String userId,
      Function(String, String) onMatchFound) {
    final data = doc.data() as Map<String, dynamic>?;
    if (data != null && data['isPermanent'] != true) {
      final users = List<String>.from(data['users'] ?? []);
      if (users.contains(userId)) {
        final otherUserId =
            users.firstWhere((id) => id != userId, orElse: () => '');
        if (otherUserId.isNotEmpty) {
          onMatchFound(doc.id, otherUserId);
        }
      }
    }
  }

  @action
  void endChat(String chatId, String userId) {
    _socketService.emit('end_chat', {'chatId': chatId, 'userId': userId});
  }

  @action
  void sendFriendRequest(String userId, String chatId) {
    _socketService.emit('add_friend', {'userId': userId, 'chatId': chatId});
  }

  @action
  void _handleChatEnded(dynamic data) {
    isChatEnded = true;
    // You might want to perform additional actions here, like updating UI
  }

  @action
  void _handleFriendRequestAccepted(dynamic data) {
    areFriendsNow = true;
    // You might want to perform additional actions here, like updating UI
    print('Friend request accepted for chat ${data['chatId']}');
  }

  @action
  Future<void> convertToPermanent(
      String anonymousChatId, String permanentChatId) async {
    _socketService.emit('convert_to_permanent', {
      'anonymousChatId': anonymousChatId,
      'permanentChatId': permanentChatId
    });
  }

  void dispose() {
    stopListeningForMatches();
    _socketService
      ..off('chat_ended')
      ..off('friend_request_accepted');
  }
}


# lib/stores/match_store.g.dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'match_store.dart';

// **************************************************************************
// StoreGenerator
// **************************************************************************

// ignore_for_file: non_constant_identifier_names, unnecessary_brace_in_string_interps, unnecessary_lambdas, prefer_expression_function_bodies, lines_longer_than_80_chars, avoid_as, avoid_annotating_with_dynamic, no_leading_underscores_for_local_identifiers

mixin _$MatchStore on _MatchStore, Store {
  late final _$isInQueueAtom =
      Atom(name: '_MatchStore.isInQueue', context: context);

  @override
  bool get isInQueue {
    _$isInQueueAtom.reportRead();
    return super.isInQueue;
  }

  @override
  set isInQueue(bool value) {
    _$isInQueueAtom.reportWrite(value, super.isInQueue, () {
      super.isInQueue = value;
    });
  }

  late final _$isSearchingAtom =
      Atom(name: '_MatchStore.isSearching', context: context);

  @override
  bool get isSearching {
    _$isSearchingAtom.reportRead();
    return super.isSearching;
  }

  @override
  set isSearching(bool value) {
    _$isSearchingAtom.reportWrite(value, super.isSearching, () {
      super.isSearching = value;
    });
  }

  late final _$isChatEndedAtom =
      Atom(name: '_MatchStore.isChatEnded', context: context);

  @override
  bool get isChatEnded {
    _$isChatEndedAtom.reportRead();
    return super.isChatEnded;
  }

  @override
  set isChatEnded(bool value) {
    _$isChatEndedAtom.reportWrite(value, super.isChatEnded, () {
      super.isChatEnded = value;
    });
  }

  late final _$areFriendsNowAtom =
      Atom(name: '_MatchStore.areFriendsNow', context: context);

  @override
  bool get areFriendsNow {
    _$areFriendsNowAtom.reportRead();
    return super.areFriendsNow;
  }

  @override
  set areFriendsNow(bool value) {
    _$areFriendsNowAtom.reportWrite(value, super.areFriendsNow, () {
      super.areFriendsNow = value;
    });
  }

  late final _$lastListenStartTimeAtom =
      Atom(name: '_MatchStore.lastListenStartTime', context: context);

  @override
  DateTime? get lastListenStartTime {
    _$lastListenStartTimeAtom.reportRead();
    return super.lastListenStartTime;
  }

  @override
  set lastListenStartTime(DateTime? value) {
    _$lastListenStartTimeAtom.reportWrite(value, super.lastListenStartTime, () {
      super.lastListenStartTime = value;
    });
  }

  late final _$_matchListenerAtom =
      Atom(name: '_MatchStore._matchListener', context: context);

  @override
  StreamSubscription<QuerySnapshot<Object?>>? get _matchListener {
    _$_matchListenerAtom.reportRead();
    return super._matchListener;
  }

  @override
  set _matchListener(StreamSubscription<QuerySnapshot<Object?>>? value) {
    _$_matchListenerAtom.reportWrite(value, super._matchListener, () {
      super._matchListener = value;
    });
  }

  late final _$currentMatchAtom =
      Atom(name: '_MatchStore.currentMatch', context: context);

  @override
  Map<String, dynamic>? get currentMatch {
    _$currentMatchAtom.reportRead();
    return super.currentMatch;
  }

  @override
  set currentMatch(Map<String, dynamic>? value) {
    _$currentMatchAtom.reportWrite(value, super.currentMatch, () {
      super.currentMatch = value;
    });
  }

  late final _$addToMatchQueueAsyncAction =
      AsyncAction('_MatchStore.addToMatchQueue', context: context);

  @override
  Future<bool> addToMatchQueue(Map<String, dynamic> userData) {
    return _$addToMatchQueueAsyncAction
        .run(() => super.addToMatchQueue(userData));
  }

  late final _$removeFromMatchQueueAsyncAction =
      AsyncAction('_MatchStore.removeFromMatchQueue', context: context);

  @override
  Future<void> removeFromMatchQueue() {
    return _$removeFromMatchQueueAsyncAction
        .run(() => super.removeFromMatchQueue());
  }

  late final _$convertToPermanentAsyncAction =
      AsyncAction('_MatchStore.convertToPermanent', context: context);

  @override
  Future<void> convertToPermanent(
      String anonymousChatId, String permanentChatId) {
    return _$convertToPermanentAsyncAction
        .run(() => super.convertToPermanent(anonymousChatId, permanentChatId));
  }

  late final _$_MatchStoreActionController =
      ActionController(name: '_MatchStore', context: context);

  @override
  void setInQueue(bool value) {
    final _$actionInfo = _$_MatchStoreActionController.startAction(
        name: '_MatchStore.setInQueue');
    try {
      return super.setInQueue(value);
    } finally {
      _$_MatchStoreActionController.endAction(_$actionInfo);
    }
  }

  @override
  void setSearching(bool value) {
    final _$actionInfo = _$_MatchStoreActionController.startAction(
        name: '_MatchStore.setSearching');
    try {
      return super.setSearching(value);
    } finally {
      _$_MatchStoreActionController.endAction(_$actionInfo);
    }
  }

  @override
  void resetMatchState() {
    final _$actionInfo = _$_MatchStoreActionController.startAction(
        name: '_MatchStore.resetMatchState');
    try {
      return super.resetMatchState();
    } finally {
      _$_MatchStoreActionController.endAction(_$actionInfo);
    }
  }

  @override
  void startListeningForMatches(
      String userId, dynamic Function(String, String) onMatchFound) {
    final _$actionInfo = _$_MatchStoreActionController.startAction(
        name: '_MatchStore.startListeningForMatches');
    try {
      return super.startListeningForMatches(userId, onMatchFound);
    } finally {
      _$_MatchStoreActionController.endAction(_$actionInfo);
    }
  }

  @override
  void stopListeningForMatches() {
    final _$actionInfo = _$_MatchStoreActionController.startAction(
        name: '_MatchStore.stopListeningForMatches');
    try {
      return super.stopListeningForMatches();
    } finally {
      _$_MatchStoreActionController.endAction(_$actionInfo);
    }
  }

  @override
  void endChat(String chatId, String userId) {
    final _$actionInfo =
        _$_MatchStoreActionController.startAction(name: '_MatchStore.endChat');
    try {
      return super.endChat(chatId, userId);
    } finally {
      _$_MatchStoreActionController.endAction(_$actionInfo);
    }
  }

  @override
  void sendFriendRequest(String userId, String chatId) {
    final _$actionInfo = _$_MatchStoreActionController.startAction(
        name: '_MatchStore.sendFriendRequest');
    try {
      return super.sendFriendRequest(userId, chatId);
    } finally {
      _$_MatchStoreActionController.endAction(_$actionInfo);
    }
  }

  @override
  void _handleChatEnded(dynamic data) {
    final _$actionInfo = _$_MatchStoreActionController.startAction(
        name: '_MatchStore._handleChatEnded');
    try {
      return super._handleChatEnded(data);
    } finally {
      _$_MatchStoreActionController.endAction(_$actionInfo);
    }
  }

  @override
  void _handleFriendRequestAccepted(dynamic data) {
    final _$actionInfo = _$_MatchStoreActionController.startAction(
        name: '_MatchStore._handleFriendRequestAccepted');
    try {
      return super._handleFriendRequestAccepted(data);
    } finally {
      _$_MatchStoreActionController.endAction(_$actionInfo);
    }
  }

  @override
  String toString() {
    return '''
isInQueue: ${isInQueue},
isSearching: ${isSearching},
isChatEnded: ${isChatEnded},
areFriendsNow: ${areFriendsNow},
lastListenStartTime: ${lastListenStartTime},
currentMatch: ${currentMatch}
    ''';
  }
}


# lib/stores/profile_store.dart
import 'package:mobx/mobx.dart';
import 'package:intl/intl.dart';
import 'package:yoto/services/serverless_service.dart';
import 'package:yoto/services/graphql_service.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'dart:convert';

part 'profile_store.g.dart';

class ProfileStore = _ProfileStore with _$ProfileStore;

abstract class _ProfileStore with Store {
  final ServerlessService _serverlessService = ServerlessService();
  final Graphqlservice _graphqlService = Graphqlservice();
  final String _cacheKey = 'profile_cache';

  @observable
  Map<String, dynamic>? profileData;

  @computed
  bool get isProfileComplete =>
      profileData != null && profileData!['profileCompleted'] == true;

  @action
  Future<void> fetchProfileData() async {
    try {
      // First, try to load from cache
      await _loadFromCache();

      // Then, fetch from server
      final fetchedData = await _graphqlService.getUserProfile();
      if (fetchedData != null) {
        profileData = fetchedData;
        // Convert birthDate string to DateTime
        if (profileData!['birthDate'] != null) {
          profileData!['birthDate'] =
              DateFormat('yyyy-MM-dd').parse(profileData!['birthDate']);
        }
        // Save to cache
        await _saveToCache();
      }
    } catch (e) {
      print('Error fetching profile data: $e');
      // If there's an error, we'll use the cached data (if available)
    }
  }

  @action
  Future<void> updateProfile(Map<String, dynamic> newData) async {
    try {
      await _serverlessService.updateProfile(newData,
          isNew: profileData == null || profileData!.isEmpty);
      await fetchProfileData(); // Fetch updated data to ensure consistency
    } catch (e) {
      print('Error updating profile: $e');
      rethrow;
    }
  }

  @action
  Future<void> _loadFromCache() async {
    final prefs = await SharedPreferences.getInstance();
    final String? cachedData = prefs.getString(_cacheKey);
    if (cachedData != null) {
      profileData = jsonDecode(cachedData);
      if (profileData!['birthDate'] != null) {
        profileData!['birthDate'] = DateTime.parse(profileData!['birthDate']);
      }
    }
  }

  @action
  Future<void> _saveToCache() async {
    final prefs = await SharedPreferences.getInstance();
    final dataToCache = Map<String, dynamic>.from(profileData!);
    if (dataToCache['birthDate'] != null) {
      dataToCache['birthDate'] =
          (dataToCache['birthDate'] as DateTime).toIso8601String();
    }
    await prefs.setString(_cacheKey, jsonEncode(dataToCache));
  }
}


# lib/stores/profile_store.g.dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'profile_store.dart';

// **************************************************************************
// StoreGenerator
// **************************************************************************

// ignore_for_file: non_constant_identifier_names, unnecessary_brace_in_string_interps, unnecessary_lambdas, prefer_expression_function_bodies, lines_longer_than_80_chars, avoid_as, avoid_annotating_with_dynamic, no_leading_underscores_for_local_identifiers

mixin _$ProfileStore on _ProfileStore, Store {
  Computed<bool>? _$isProfileCompleteComputed;

  @override
  bool get isProfileComplete => (_$isProfileCompleteComputed ??= Computed<bool>(
          () => super.isProfileComplete,
          name: '_ProfileStore.isProfileComplete'))
      .value;

  late final _$profileDataAtom =
      Atom(name: '_ProfileStore.profileData', context: context);

  @override
  Map<String, dynamic>? get profileData {
    _$profileDataAtom.reportRead();
    return super.profileData;
  }

  @override
  set profileData(Map<String, dynamic>? value) {
    _$profileDataAtom.reportWrite(value, super.profileData, () {
      super.profileData = value;
    });
  }

  late final _$fetchProfileDataAsyncAction =
      AsyncAction('_ProfileStore.fetchProfileData', context: context);

  @override
  Future<void> fetchProfileData() {
    return _$fetchProfileDataAsyncAction.run(() => super.fetchProfileData());
  }

  late final _$updateProfileAsyncAction =
      AsyncAction('_ProfileStore.updateProfile', context: context);

  @override
  Future<void> updateProfile(Map<String, dynamic> newData) {
    return _$updateProfileAsyncAction.run(() => super.updateProfile(newData));
  }

  late final _$_loadFromCacheAsyncAction =
      AsyncAction('_ProfileStore._loadFromCache', context: context);

  @override
  Future<void> _loadFromCache() {
    return _$_loadFromCacheAsyncAction.run(() => super._loadFromCache());
  }

  late final _$_saveToCacheAsyncAction =
      AsyncAction('_ProfileStore._saveToCache', context: context);

  @override
  Future<void> _saveToCache() {
    return _$_saveToCacheAsyncAction.run(() => super._saveToCache());
  }

  @override
  String toString() {
    return '''
profileData: ${profileData},
isProfileComplete: ${isProfileComplete}
    ''';
  }
}


# lib/widgets/auth_button.dart
import 'package:flutter/material.dart';

class AuthButton extends StatelessWidget {
  final String text;
  final VoidCallback onPressed;

  const AuthButton({super.key, required this.text, required this.onPressed});

  @override
  Widget build(BuildContext context) {
    return ElevatedButton(
      onPressed: onPressed,
      style: ElevatedButton.styleFrom(
        backgroundColor: Theme.of(context).primaryColor,
        padding: const EdgeInsets.symmetric(horizontal: 50, vertical: 15),
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(30),
        ),
      ),
      child: Text(text, style: const TextStyle(color: Colors.white)),
    );
  }
}


# lib/widgets/chat_appbar.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:yoto/stores/friend_store.dart';

class ChatAppBar extends StatefulWidget implements PreferredSizeWidget {
  final String friendId;
  final bool isFriend;
  final int timerValue;
  final VoidCallback onEndChat;

  const ChatAppBar({
    Key? key,
    required this.friendId,
    required this.isFriend,
    required this.timerValue,
    required this.onEndChat,
  }) : super(key: key);

  @override
  Size get preferredSize => const Size.fromHeight(kToolbarHeight);

  @override
  _ChatAppBarState createState() => _ChatAppBarState();
}

class _ChatAppBarState extends State<ChatAppBar> {
  String friendName = 'Strange';
  String avatar = '';

  @override
  void initState() {
    super.initState();
    if (widget.isFriend) {
      _loadFriendProfile();
    }
  }

  Future<void> _loadFriendProfile() async {
    final friendStore = Provider.of<FriendStore>(context, listen: false);
    final friendProfile = await friendStore.getFriendProfile(widget.friendId);
    if (friendProfile != null) {
      setState(() {
        friendName = friendProfile['displayName'];
        avatar = friendProfile['profileImageUrl'];
      });
    }
  }

  String _formatTime(int seconds) {
    int minutes = seconds ~/ 60;
    int remainingSeconds = seconds % 60;
    return '${minutes.toString().padLeft(2, '0')}:${remainingSeconds.toString().padLeft(2, '0')}';
  }

  @override
  Widget build(BuildContext context) {
    final isDarkMode = Theme.of(context).brightness == Brightness.dark;
    return AppBar(
      backgroundColor: isDarkMode ? Colors.grey[900] : Colors.white,
      elevation: 0,
      leading: IconButton(
        icon: Icon(Icons.arrow_back,
            color: isDarkMode ? Colors.white : Colors.black),
        onPressed: () => Navigator.of(context).pop(),
      ),
      title: Text(
        friendName,
        style: TextStyle(
          color: isDarkMode ? Colors.white : Colors.black,
          fontWeight: FontWeight.bold,
        ),
      ),
      actions: [
        if (!widget.isFriend) ...[
          Center(
            child: Text(
              _formatTime(widget.timerValue),
              style: TextStyle(
                fontSize: 12,
                color: isDarkMode ? Colors.white : Colors.black,
              ),
            ),
          ),
          PopupMenuButton<String>(
            onSelected: (value) {
              if (value == 'sendFriendRequest') {
                // Implement send friend request
              } else if (value == 'endChat') {
                widget.onEndChat();
              }
            },
            itemBuilder: (BuildContext context) => [
              const PopupMenuItem<String>(
                value: 'sendFriendRequest',
                child: Text('Send Friend Request'),
              ),
              const PopupMenuItem<String>(
                value: 'endChat',
                child: Text('End Chat'),
              ),
            ],
          ),
        ] else ...[
          CircleAvatar(
            backgroundImage: NetworkImage(avatar),
            radius: 18,
          ),
        ],
        const SizedBox(width: 16),
      ],
    );
  }
}


# lib/widgets/chat_input_area.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:yoto/stores/chat_store.dart';
import 'package:yoto/stores/auth_store.dart';

class ChatInputArea extends StatefulWidget {
  final String chatId;
  final bool isFriend;

  const ChatInputArea({Key? key, required this.chatId, required this.isFriend})
      : super(key: key);

  @override
  ChatInputAreaState createState() => ChatInputAreaState();
}

class ChatInputAreaState extends State<ChatInputArea> {
  final TextEditingController _textController = TextEditingController();

  void _handleSendPressed() {
    if (_textController.text.trim().isNotEmpty) {
      final chatStore = Provider.of<ChatStore>(context, listen: false);
      final authStore = Provider.of<AuthStore>(context, listen: false);
      chatStore.sendMessage(widget.chatId, _textController.text.trim(),
          authStore.currentUser!.uid);
      _textController.clear();
    }
  }

  @override
  Widget build(BuildContext context) {
    final isDarkMode = Theme.of(context).brightness == Brightness.dark;
    final backgroundColor = isDarkMode ? Colors.grey[900] : Colors.white;
    final inputBackgroundColor =
        isDarkMode ? Colors.grey[800] : Colors.grey[200];
    final iconColor = isDarkMode ? Colors.grey[400] : Colors.grey[600];
    final textColor = isDarkMode ? Colors.white : Colors.black;

    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 8.0, vertical: 8.0),
      color: backgroundColor,
      child: Row(
        children: [
          if (widget.isFriend)
            IconButton(
              icon: Icon(Icons.add, color: iconColor),
              onPressed: () {
                // Implement add attachment functionality
              },
            ),
          Expanded(
            child: ConstrainedBox(
              constraints: const BoxConstraints(
                minHeight: 40.0,
                maxHeight: 120.0,
              ),
              child: TextField(
                controller: _textController,
                focusNode: FocusNode(),
                maxLines: null,
                textCapitalization: TextCapitalization.sentences,
                style: TextStyle(color: textColor),
                decoration: InputDecoration(
                  hintText: 'Aa',
                  hintStyle: TextStyle(color: iconColor),
                  border: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(24.0),
                    borderSide: BorderSide.none,
                  ),
                  filled: true,
                  fillColor: inputBackgroundColor,
                  contentPadding: const EdgeInsets.symmetric(
                      horizontal: 16.0, vertical: 8.0),
                ),
              ),
            ),
          ),
          if (widget.isFriend)
            IconButton(
              icon: Icon(Icons.mic, color: iconColor),
              onPressed: () {
                // Implement voice message functionality
              },
            ),
          IconButton(
            icon: Icon(Icons.send, color: iconColor),
            onPressed: _handleSendPressed,
          ),
        ],
      ),
    );
  }

  @override
  void dispose() {
    _textController.dispose();
    super.dispose();
  }
}


# lib/widgets/chat_message_list.dart
import 'package:flutter/material.dart';
import 'package:flutter_mobx/flutter_mobx.dart';
import 'package:provider/provider.dart';
import 'package:yoto/stores/chat_store.dart';
import 'package:yoto/widgets/message_bubble.dart';

class ChatMessageList extends StatelessWidget {
  final String chatId;
  final ScrollController _scrollController = ScrollController();

  ChatMessageList({Key? key, required this.chatId}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final chatStore = Provider.of<ChatStore>(context);

    return Observer(
      builder: (_) {
        final messages = chatStore.getMessagesForChat(chatId);

        WidgetsBinding.instance.addPostFrameCallback((_) {
          if (_scrollController.hasClients) {
            _scrollController.animateTo(
              0.0,
              duration: const Duration(milliseconds: 300),
              curve: Curves.easeOut,
            );
          }
        });

        return ListView.builder(
          reverse: true,
          controller: _scrollController,
          itemCount: messages.length,
          itemBuilder: (context, index) {
            return MessageBubble(message: messages[index]);
          },
        );
      },
    );
  }
}


# lib/widgets/custome_chat_list_item.dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/material.dart';
import 'package:yoto/stores/friend_store.dart';

class CustomChatListItem extends StatelessWidget {
  final Friend friend;
  final VoidCallback onTap;

  const CustomChatListItem({
    Key? key,
    required this.friend,
    required this.onTap,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return ListTile(
      leading: CircleAvatar(
        backgroundImage: friend.profileImageUrl != null
            ? NetworkImage(friend.profileImageUrl!)
            : null,
        child:
            friend.profileImageUrl == null ? Text(friend.displayName[0]) : null,
      ),
      title: Text(friend.displayName),
      subtitle: Text(
        friend.lastMessage,
        maxLines: 1,
        overflow: TextOverflow.ellipsis,
      ),
      trailing: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        crossAxisAlignment: CrossAxisAlignment.end,
        children: [
          Text(
            _formatTimestamp(friend.lastMessageTime),
            style: const TextStyle(fontSize: 12, color: Colors.grey),
          ),
          if (friend.unreadCount > 0)
            Container(
              padding: const EdgeInsets.all(6),
              decoration: BoxDecoration(
                color: Theme.of(context).primaryColor,
                shape: BoxShape.circle,
              ),
              child: Text(
                friend.unreadCount.toString(),
                style: const TextStyle(color: Colors.white, fontSize: 12),
              ),
            ),
        ],
      ),
      onTap: onTap,
    );
  }

  String _formatTimestamp(Timestamp timestamp) {
    final now = DateTime.now();
    final date = timestamp.toDate();
    final difference = now.difference(date);

    if (difference.inDays == 0) {
      return '${date.hour}:${date.minute.toString().padLeft(2, '0')}';
    } else if (difference.inDays < 7) {
      return [
        'Mon',
        'Tue',
        'Wed',
        'Thu',
        'Fri',
        'Sat',
        'Sun'
      ][date.weekday - 1];
    } else {
      return '${date.day}/${date.month}/${date.year}';
    }
  }
}


# lib/widgets/custome_text_field.dart
import 'package:flutter/material.dart';

class CustomTextField extends StatelessWidget {
  final TextEditingController controller;
  final String hintText;
  final IconData icon;
  final bool obscureText;
  final String? Function(String?)? validator;

  const CustomTextField({
    super.key,
    required this.controller,
    required this.hintText,
    required this.icon,
    this.obscureText = false,
    this.validator,
  });

  @override
  Widget build(BuildContext context) {
    final isDarkMode = Theme.of(context).brightness == Brightness.dark;

    return TextFormField(
      controller: controller,
      obscureText: obscureText,
      decoration: InputDecoration(
        hintText: hintText,
        prefixIcon: Icon(icon, color: Theme.of(context).primaryColor),
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(30),
          borderSide: BorderSide(color: Theme.of(context).primaryColor),
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(30),
          borderSide:
              BorderSide(color: Theme.of(context).primaryColor, width: 2),
        ),
        fillColor: isDarkMode ? Colors.grey[800] : Colors.grey[200],
        filled: true,
      ),
      style: TextStyle(color: isDarkMode ? Colors.white : Colors.black),
      validator: validator,
    );
  }
}


# lib/widgets/message_bubble.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:intl/intl.dart';
import 'package:yoto/stores/auth_store.dart';

class MessageBubble extends StatelessWidget {
  final dynamic message;

  const MessageBubble({Key? key, required this.message}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final authStore = Provider.of<AuthStore>(context, listen: false);
    final isMe = message.author.id == authStore.currentUser!.uid;
    final isDarkMode = Theme.of(context).brightness == Brightness.dark;

    final myMessageColor = isDarkMode ? Colors.teal[700] : Colors.blue[100];
    final otherMessageColor = isDarkMode ? Colors.grey[800] : Colors.grey[200];
    final textColor = isDarkMode ? Colors.white : Colors.black;
    final timestampColor = isDarkMode ? Colors.grey[400] : Colors.grey[600];

    return Align(
      alignment: isMe ? Alignment.centerRight : Alignment.centerLeft,
      child: Container(
        margin: const EdgeInsets.symmetric(vertical: 4, horizontal: 8),
        padding: const EdgeInsets.symmetric(vertical: 8, horizontal: 12),
        decoration: BoxDecoration(
          color: isMe ? myMessageColor : otherMessageColor,
          borderRadius: BorderRadius.circular(20),
          boxShadow: [
            BoxShadow(
              color: Colors.black.withOpacity(0.1),
              blurRadius: 3,
              offset: const Offset(0, 2),
            ),
          ],
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              message.text,
              style: TextStyle(
                fontSize: 16,
                color: textColor,
              ),
            ),
            const SizedBox(height: 4),
            Text(
              DateFormat('HH:mm').format(
                DateTime.fromMillisecondsSinceEpoch(message.createdAt),
              ),
              style: TextStyle(
                fontSize: 12,
                color: timestampColor,
              ),
            ),
          ],
        ),
      ),
    );
  }
}

# lib/widgets/search_animation.dart
import 'package:flutter/material.dart';

class SearchAnimation extends StatefulWidget {
  const SearchAnimation({super.key});

  @override
  SearchAnimationState createState() => SearchAnimationState();
}

class SearchAnimationState extends State<SearchAnimation>
    with SingleTickerProviderStateMixin {
  late AnimationController _animationController;
  late Animation<double> _scaleAnimation;

  @override
  void initState() {
    super.initState();
    _setupAnimation();
  }

  void _setupAnimation() {
    _animationController = AnimationController(
      duration: const Duration(milliseconds: 1000),
      vsync: this,
    )..repeat(reverse: true);

    _scaleAnimation = Tween<double>(begin: 0.9, end: 1.0).animate(
      CurvedAnimation(
        parent: _animationController,
        curve: Curves.easeInOut,
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return AnimatedBuilder(
      animation: _scaleAnimation,
      builder: (BuildContext context, Widget? child) {
        return Transform.scale(
          scale: _scaleAnimation.value,
          child: Container(
            width: 200,
            height: 200,
            decoration: const BoxDecoration(
              shape: BoxShape.circle,
              color: Colors.blue,
            ),
            child: const Icon(
              Icons.search,
              color: Colors.white,
              size: 50,
            ),
          ),
        );
      },
    );
  }

  @override
  void dispose() {
    _animationController.dispose();
    super.dispose();
  }
}


# lib/widgets/search_button.dart
import 'package:flutter/material.dart';

class SearchButton extends StatelessWidget {
  final bool isSearching;
  final VoidCallback onStartSearch;
  final VoidCallback onStopSearch;

  const SearchButton({
    Key? key,
    required this.isSearching,
    required this.onStartSearch,
    required this.onStopSearch,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return isSearching
        ? ElevatedButton(
            onPressed: onStopSearch,
            style: ElevatedButton.styleFrom(backgroundColor: Colors.red),
            child: const Text('Stop Search'),
          )
        : ElevatedButton(
            onPressed: onStartSearch,
            child: const Text('Start Search'),
          );
  }
}


